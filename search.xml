<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>220124周报</title>
    <url>/post/2353082c.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li><p>重构Module</p>
</li>
<li><p>新增编制单位成员信息表</p>
</li>
<li><p>名称修改（简写）</p>
</li>
<li><p>新增流程统计</p>
</li>
<li><p>新增历史建筑录入流程</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220130周报</title>
    <url>/post/78c339fd.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li>移除通用查询，重写CRUD</li>
<li>流程与具体业务分离</li>
<li>新增单位成员</li>
<li>修改审批为候选组（角色）审批</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220207周报</title>
    <url>/post/df3f5073.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li><p>新增模糊分页查询</p>
</li>
<li><p>修改新增申请接口为保护规划+多个编制单位及成员</p>
</li>
<li><p>移除多余接口</p>
</li>
<li><p>新增项目编码（流水号）生成</p>
</li>
<li><p>新建历史建筑接口</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220214周报</title>
    <url>/post/5f2d3088.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li>接入用户系统</li>
<li>DO基类：记录创建日期、更新日期</li>
<li>整理无用流程接口</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220221周报</title>
    <url>/post/46a97c4.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li>BaseAppDO：整合通用审批</li>
<li>合并流程查询</li>
<li>README文档整理</li>
<li>合并申请表查询</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220228周报</title>
    <url>/post/2f1e77bf.html</url>
    <content><![CDATA[<h1 id="管道燃气"><a href="#管道燃气" class="headerlink" title="管道燃气"></a>管道燃气</h1><ul>
<li><input checked="" disabled="" type="checkbox"> Mock数据</li>
<li><input checked="" disabled="" type="checkbox"> 企业相关CRUD</li>
<li><input checked="" disabled="" type="checkbox"> 数据字典转换SQL脚本</li>
</ul>
<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 更新统计底数</li>
</ul>
<h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 评论通知</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220314周报</title>
    <url>/post/e79157ed.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 技术说明文档（README）</li>
<li><input checked="" disabled="" type="checkbox"> 成果数据存储</li>
</ul>
<h1 id="个人Spring模板"><a href="#个人Spring模板" class="headerlink" title="个人Spring模板"></a>个人Spring模板</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 通用CRUD</li>
<li><input checked="" disabled="" type="checkbox"> Swagger配置</li>
<li><input checked="" disabled="" type="checkbox"> 静态资源映射</li>
<li><input checked="" disabled="" type="checkbox"> 异常处理</li>
<li><input checked="" disabled="" type="checkbox"> 通用条件查询</li>
<li><input checked="" disabled="" type="checkbox"> 技术说明文档（README）</li>
<li><input disabled="" type="checkbox"> 统一HTTP访问</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220307周报</title>
    <url>/post/cf733f29.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 异常处理</li>
<li><input checked="" disabled="" type="checkbox"> 时间序列化处理</li>
<li><input checked="" disabled="" type="checkbox"> 流程全局监听</li>
<li><input checked="" disabled="" type="checkbox"> 日志推送</li>
<li><input disabled="" type="checkbox"> 消息推送</li>
<li><input checked="" disabled="" type="checkbox"> 通用CRUD</li>
<li><input disabled="" type="checkbox"> 技术说明文档（README）</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220321周报</title>
    <url>/post/bcd6f0a1.html</url>
    <content><![CDATA[<h1 id="三名系统"><a href="#三名系统" class="headerlink" title="三名系统"></a>三名系统</h1><ul>
<li><input checked="" disabled="" type="checkbox"> API自动化测试</li>
</ul>
<h1 id="Java技术栈"><a href="#Java技术栈" class="headerlink" title="Java技术栈"></a>Java技术栈</h1><ul>
<li><input checked="" disabled="" type="checkbox"> JVM</li>
<li><input checked="" disabled="" type="checkbox"> Network</li>
<li><input disabled="" type="checkbox"> MySQL</li>
</ul>
<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 版本升级</li>
<li><input checked="" disabled="" type="checkbox"> 评论系统</li>
<li><input checked="" disabled="" type="checkbox"> 目录与文件夹映射</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220411周报</title>
    <url>/post/47134c05.html</url>
    <content><![CDATA[<h1 id="项目学习"><a href="#项目学习" class="headerlink" title="项目学习"></a>项目学习</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 测试流程整理</li>
<li><input checked="" disabled="" type="checkbox"> 部署流程整理</li>
</ul>
<h1 id="配置整理"><a href="#配置整理" class="headerlink" title="配置整理"></a>配置整理</h1><ul>
<li><input checked="" disabled="" type="checkbox"> Typora</li>
<li><input checked="" disabled="" type="checkbox"> IDEA</li>
</ul>
<h1 id="代码整理"><a href="#代码整理" class="headerlink" title="代码整理"></a>代码整理</h1><ul>
<li><input disabled="" type="checkbox"> Python</li>
</ul>
<h1 id="Kafka学习"><a href="#Kafka学习" class="headerlink" title="Kafka学习"></a>Kafka学习</h1><ul>
<li><input disabled="" type="checkbox"> 并行度</li>
<li><input disabled="" type="checkbox"> 消费组</li>
<li><input disabled="" type="checkbox"> MessageListener</li>
</ul>
<h1 id="OneDrive修复"><a href="#OneDrive修复" class="headerlink" title="OneDrive修复"></a>OneDrive修复</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 应用重装</li>
<li><input disabled="" type="checkbox"> 数据同步</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220404周报</title>
    <url>/post/d981633c.html</url>
    <content><![CDATA[<h1 id="装机配置"><a href="#装机配置" class="headerlink" title="装机配置"></a>装机配置</h1><ul>
<li><input checked="" disabled="" type="checkbox"> IDEA</li>
<li><input checked="" disabled="" type="checkbox"> JDK8</li>
<li><input checked="" disabled="" type="checkbox"> Git</li>
<li><input checked="" disabled="" type="checkbox"> VSCode</li>
<li><input checked="" disabled="" type="checkbox"> Pycharm</li>
<li><input checked="" disabled="" type="checkbox"> FinalShell</li>
<li><input checked="" disabled="" type="checkbox"> navicat</li>
<li><input checked="" disabled="" type="checkbox"> 向日葵远程控制</li>
<li><input checked="" disabled="" type="checkbox"> 向日葵控制端</li>
<li><input checked="" disabled="" type="checkbox"> ToDesk</li>
<li><input checked="" disabled="" type="checkbox"> QGIS</li>
</ul>
<h1 id="GIS学习"><a href="#GIS学习" class="headerlink" title="GIS学习"></a>GIS学习</h1><ul>
<li><input disabled="" type="checkbox"> 《地理信息系统导论》</li>
</ul>
<h1 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 设计架构</li>
<li><input checked="" disabled="" type="checkbox"> 源码</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220418周报</title>
    <url>/post/d28b09d6.html</url>
    <content><![CDATA[<h1 id="代码整理"><a href="#代码整理" class="headerlink" title="代码整理"></a>代码整理</h1><ul>
<li><input disabled="" type="checkbox"> Python</li>
</ul>
<h1 id="Kafka学习"><a href="#Kafka学习" class="headerlink" title="Kafka学习"></a>Kafka学习</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 并行度</li>
<li><input checked="" disabled="" type="checkbox"> 消费组</li>
<li><input checked="" disabled="" type="checkbox"> MessageListener</li>
<li><input checked="" disabled="" type="checkbox"> Deployment</li>
<li><input checked="" disabled="" type="checkbox"> 高可用</li>
<li><input checked="" disabled="" type="checkbox"> 可靠性传输</li>
<li><input checked="" disabled="" type="checkbox"> Kafka 账户密码</li>
</ul>
<h1 id="OneDrive修复"><a href="#OneDrive修复" class="headerlink" title="OneDrive修复"></a>OneDrive修复</h1><ul>
<li><input disabled="" type="checkbox"> 数据同步</li>
</ul>
<h1 id="gis-preview"><a href="#gis-preview" class="headerlink" title="gis-preview"></a>gis-preview</h1><ul>
<li><input checked="" disabled="" type="checkbox"> Kafka 接入</li>
<li><input checked="" disabled="" type="checkbox"> Kafka 配置整理</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220425周报</title>
    <url>/post/3dd36ff5.html</url>
    <content><![CDATA[<h1 id="CSP-接入-WFS"><a href="#CSP-接入-WFS" class="headerlink" title="CSP 接入 WFS"></a>CSP 接入 WFS</h1><ul>
<li><input checked="" disabled="" type="checkbox"> WFS 学习</li>
<li><input checked="" disabled="" type="checkbox"> 组件熟悉</li>
<li><input checked="" disabled="" type="checkbox"> 环境搭建</li>
<li><input checked="" disabled="" type="checkbox"> Camel 学习</li>
<li><input checked="" disabled="" type="checkbox"> Karaf 学习</li>
</ul>
<h1 id="代码整理"><a href="#代码整理" class="headerlink" title="代码整理"></a>代码整理</h1><ul>
<li><input disabled="" type="checkbox"> Python</li>
</ul>
<h1 id="OneDrive修复"><a href="#OneDrive修复" class="headerlink" title="OneDrive修复"></a>OneDrive修复</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 数据同步</li>
</ul>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220502周报</title>
    <url>/post/ad2a4245.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
  <tr>
    <td rowspan="2">中青会</td>
    <td>任务管理工具替换</td>
    <td>已将板栗看板中本周的任务进度迁移至多维表格“任务管理”中</td>
    <td>陆续迁移之前的任务进度</td>
  </tr>
  <tr>
    <td>文案撰写</td>
    <td>面试官流程指南、活动手册已完成</td>
    <td>尽快撰写退费政策</td>
  </tr>
  <tr>
    <td rowspan="2">个人代码</td>
    <td>Python</td>
    <td>五一假期，未安排时间</td>
    <td>尽快整理</td>
  </tr>
  <tr>
    <td>Java</td>
    <td>五一假期，未安排时间</td>
    <td>尽快整理</td>
  </tr>
  <tr>
    <td rowspan="3">CSP 支持 WFS</td>
    <td>环境搭建</td>
    <td>CSP 开发团队遗漏了 acbb 的 zuul 网关配置，导致多环境下 cookie 丢失的 BUG，现已修复，开发环境上线</td>
    <td>在搭建好的环境中进行二次开发</td>
  </tr>
  <tr>
    <td>WFS 操作整理</td>
    <td>整理了当前版本支持的三种操作</td>
    <td>正式投入 WFS 服务开发</td>
  </tr>
   <tr>
    <td>GML 生成</td>
    <td>初步了解几种生成方法</td>
    <td>进一步学习熟悉 GML 格式</td>
  </tr>
  <tr>
    <td rowspan="4">个人 Spring 项目模板</td>
    <td>自定义注解学习整理</td>
    <td>学习并简单使用了自定义注解，初步掌握</td>
    <td>后续可能会投入使用</td>
  </tr>
  <tr>
    <td>拦截器学习整理</td>
    <td>学习并简单使用了拦截器，初步掌握</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>HTTP 工具类整理</td>
    <td>结合前人经验与个人使用习惯，新增 HTTP 请求工具类</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>代码整理</td>
    <td>修复 JDK1.8 的 List 相关 BUG，完善注解@Transactional与@Resource，调整个别命名与目录位置</td>
    <td>暂无</td>
  </tr>
</table>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220509周报</title>
    <url>/post/af2d16bf.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
  <tr>
    <td rowspan="3">CSP 接入 WFS</td>
    <td>GML 生成</td>
    <td>SAX/DOM操作学习：创建、解析、遍历、搜索、新增、修改、删除、写入</td>
    <td>已投入实际开发</td>
  </tr>
  <tr>
    <td>GetCapabilities 接口开发</td>
    <td>完成度 80%，目前没有碰到太多阻力</td>
    <td>剩余部分待对接的数据和待明确的特定字段——命名空间</td>
  </tr>
  <tr>
    <td>DescribeFeatureType 接口开发</td>
    <td>完成度 20%，用 GeoTools 已经初步生成了所需数据</td>
    <td>待进一步开发</td>
  </tr>
  <tr>
    <td rowspan="1">个人 Spring 模板</td>
    <td>工具类新增</td>
    <td>新增hutool、commons-lang3</td>
    <td>暂无</td>
  </tr>
  <tr>
   <td rowspan="2">个人代码</td>
    <td>数据打包</td>
    <td>部分数据数量较大，打包后删除原数据，便于云同步</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>第三方代码移除</td>
    <td>无用的第三方代码，尤其是 vue 相关，包含大量小文件，导致云同步非常困难</td>
    <td>暂无</td>
  </tr>
</table>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220516周报</title>
    <url>/post/95cf66c8.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
  <tr>
    <td rowspan="5">CSP 接入 WFS</td>
    <td>GetCapabilities 接口开发</td>
    <td>已完成</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>DescribeFeatureType 接口开发</td>
    <td>已完成，因为 Karaf 的依赖问题堵塞，无法最终测试待堵塞问题解决后，进行测试</td>
    <td>待堵塞问题解决后，尽早完成测试</td>
  </tr>
    <td>参数校验</td>
    <td>已完成，已测试</td>
    <td>将参数默认值设置从中移除</td>
  </tr>
    <td>异常处理</td>
    <td>已完成，已测试</td>
    <td>暂无</td>
  </tr>
    <td>参数默认值设置</td>
    <td>已完成，但需要改进，暂不会在当前版本被感知，仅影响操作返回值参数移除</td>
    <td>进一步完善</td>
  </tr>
</table>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220523周报</title>
    <url>/post/49784e8c.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
  <tr>
    <td rowspan="2">CSP 接入 WFS</td>
    <td>参数默认值设置</td>
    <td>已从参数校验移除</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>Karaf/OSGi 整理</td>
    <td>已输出文档</td>
    <td>根据未来项目中框架的使用情况，有针对性地学习</td>
  </tr>
    <tr>
    <td rowspan="3">CSP 接入 WMS</td>
    <td>WMS 规范整理</td>
    <td>OGC 规范整理已完成，GeoServer 规范整理已完成，应急规范已截取，单独成文件
</td>
    <td>或考虑进一步整理操作响应规范</td>
  </tr>
  <tr>
    <td>GeoServer 发布 WMS</td>
    <td>已完成，但由于缺少合适的数据，GetFeatureInfo 操作未能测试成功</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>CSP 接入 WMS 分析</td>
    <td>已完成</td>
    <td>需要进一步分析 GetFeatureInfo 操作的可行性</td>
  </tr>
</table>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220606周报</title>
    <url>/post/60e85a93.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
    <td rowspan="6">CSP 支持 WMS</td>
    <td>CSP 支持 WMS 分析</td>
    <td>完善文档。</td>
    <td>根据实际需求，继续完善。</td>
  </tr>
  <tr>
    <td>空间数据接口接入指南</td>
    <td>完善文档，整理异常类型。</td>
    <td>根据实际需求，继续完善。</td>
  </tr>
  <tr>
    <td>测试用例</td>
    <td>已撰写。</td>
    <td>根据实际需求，继续完善。</td>
  </tr>
  <tr>
    <td>GetCapabilities 接口开发</td>
    <td>参数校验、输出格式化已开发，文件生成待开发。</td>
    <td>文件生成，系统测试。</td>
  </tr>
  <tr>
    <td>GetMap 接口开发</td>
    <td>参数校验、SQL 生成、输出格式化已开发。</td>
    <td>系统测试。</td>
  </tr>
  <tr>
    <td>异常处理</td>
    <td>部分重构，新增 GisExceptionEntity 数据结构，新增 JSON 格式化。</td>
    <td>系统测试。</td>
  </tr>
  <tr>
    <td rowspan="1">CSP 支持 WFS</td>
    <td>GetCapabilities 多图层支持</td>
    <td>暂未开始。</td>
    <td>FeatureType 待新增。</td>
  </tr>
</table>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220613周报</title>
    <url>/post/fe7a75aa.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
  <tr>
    <td rowspan="5">CSP 支持 WMS</td>
    <td>GetCapabilities 接口开发</td>
    <td>参数校验、SQL 生成、输出格式化已开发。</td>
    <td>待系统测试。</td>
  </tr>
  <tr>
    <td>GetMap 接口开发</td>
    <td>参数校验、SQL 生成、输出格式化已开发。</td>
    <td>待系统测试。</td>
  </tr>
  <tr>
    <td>路由配置</td>
    <td>已支持。</td>
    <td>待系统测试。</td>
  </tr>
  <tr>
    <td>服务商信息配置化</td>
    <td>已支持。</td>
    <td>无系统测试。</td>
  </tr>
  <tr>
    <td>空间数据接口接入指南</td>
    <td>完善文档，整理异常类型。</td>
    <td>根据实际需求，继续完善。</td>
  </tr>
  <tr>
    <td rowspan="3">CSP 支持 WFS</td>
    <td>GetCapabilities 多图层支持</td>
    <td>FeatureTypeList 已支持。</td>
    <td>待系统测试。</td>
  </tr>
  <tr>
    <td>DescribeFeatureType 多图层支持</td>
    <td>多 complexType 已支持。</td>
    <td>待系统测试。</td>
  </tr>
  <tr>
    <td>服务商信息配置化</td>
    <td>已支持。</td>
    <td>无系统测试。</td>
  </tr>
</table>

]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220620周报</title>
    <url>/post/411d68d4.html</url>
    <content><![CDATA[<table>
  <tr>
    <th>项目</th>
    <th>任务</th>
    <th>进度</th>
    <th>计划</th>
  </tr>
  <tr>
    <td rowspan="3">CSP 支持 WMS</td>
    <td>GetCapabilities 接口开发</td>
    <td>已系统测试。</td>
    <td>暂无。</td>
  </tr>
  <tr>
    <td>GetMap 接口开发</td>
    <td>排查并解决了类加载机制问题、OpenJDK 对于 JPEG 支持的问题等，已系统测试。</td>
    <td>暂无。</td>
  </tr>
  <tr>
    <td>路由配置</td>
    <td>已系统测试。</td>
    <td>暂无。</td>
  </tr>
  <tr>
    <td rowspan="2">CSP 支持 WFS</td>
    <td>GetCapabilities 多图层支持</td>
    <td>已系统测试。</td>
    <td>暂无。</td>
  </tr>
  <tr>
    <td>DescribeFeatureType 多图层支持</td>
    <td>已系统测试。</td>
    <td>暂无。</td>
  </tr>
</table>

]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220704周报</title>
    <url>/post/e00c5ff9.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
 <tr>
    <td rowspan="2">CSP 代码学习</td>
    <td>WMTS 代码学习</td>
    <td>已有较为系统的了解</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>CSP 网关代码学习</td>
    <td>已有较为系统的了解</td>
    <td>暂无</td>
  </tr>
 <tr>
    <td rowspan="2">CSP 支持 WCS</td>
    <td>CSP 支持 WCS 分析</td>
    <td>博天同学已开始参照过往文本进行整理，以协助为主</td>
    <td>需要根据当前减灾一线的公共需求，动态投入</td>
  </tr>
  <tr>
    <td>GeoTools 操作栅格数据学习</td>
    <td>已有初步了解</td>
    <td>需要根据当前减灾一线的公共需求，动态投入</td>
  </tr>  
</table>

]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220712周报</title>
    <url>/post/4f766a5d.html</url>
    <content><![CDATA[<table>
    <tr>
    <th>项目</th>
    <th>任务</th>
        <th>进度</th>
        <th>计划</th>
  <tr>
 <tr>
    <td rowspan="3">GeoData</td>
    <td>CPU 对切图效率影响的测试</td>
    <td>已得出结论，同步至开发</td>
    <td>暂无</td>
  </tr>
  <tr>
    <td>GeoData 代码学习</td>
    <td>已对 gis-scheduling、gis-script 有基本了解，配合 Tippecanoe 相关命令熟悉业务代码</td>
    <td>继续跟进</td>
  </tr>
  <tr>
    <td>Tippecanoe 学习</td>
    <td>阅读官方文档，按需学习了部分命令</td>
    <td>继续跟进</td>
  </tr>
 <tr>
    <td rowspan="2">CSP 支持 WFS/WMS</td>
    <td>BBOX 优化</td>
    <td>系统测试完毕，验证有效</td>
    <td>待未来版本合入主线</td>
  </tr>
  <tr>
    <td>WFS GetCapabilitiy BUG 修复</td>
    <td>修复完成，已并入主线</td>
    <td>暂无</td>
  </tr>  
</table>
]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>220712周报</title>
    <url>/post/4f766a5d.html</url>
    <content><![CDATA[<table>
    <tr>
        <th>项目</th>
        <th>任务</th>
        <th>进度</th>
        <th>计划</th>
    <tr>
    <tr>
        <td rowspan="3">工作交接</td>
        <td>GeoData 交接</td>
        <td>已交接，无异常</td>
        <td>无</td>
      </tr>
    <tr>
        <td>CSP 交接</td>
        <td>已交接，无异常</td>
        <td>无</td>
     </tr>
</table>

]]></content>
      <categories>
        <category>Weekly</category>
      </categories>
  </entry>
  <entry>
    <title>Capslock+</title>
    <url>/post/232a6741.html</url>
    <content><![CDATA[<blockquote>
<p>Capslock+是一个加强 Capslock 键的功能，以提高效率的工具。</p>
</blockquote>
<h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><ul>
<li>官网链接：<a href="https://capslox.com/capslock-plus/">Capslock+</a></li>
<li>Windows 版本免费，macOS 版本付费</li>
</ul>
<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><ul>
<li>键位参考：vim</li>
<li>需求：禁用 CapsLock 本身或替换为 esc</li>
</ul>
<h2 id="CapsLock-settings-ini"><a href="#CapsLock-settings-ini" class="headerlink" title="CapsLock+settings.ini"></a>CapsLock+settings.ini</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;------------ Encoding: UTF-16 ------------</span></span><br><span class="line"><span class="comment">;请对照 CapsLock+settingsDemo.ini 来配置相关设置</span></span><br><span class="line"><span class="section">[Global]</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">loadScript</span>=scriptDemo.js</span><br><span class="line"></span><br><span class="line"><span class="section">[QSearch]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[QRun]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[QWeb]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[TabHotString]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[QStyle]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[TTranslate]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Keys]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">press_caps</span>=keyFunc_esc</span><br><span class="line"><span class="attr">caps_k</span>=keyFunc_moveUp</span><br><span class="line"><span class="attr">caps_j</span>=keyFunc_moveDown</span><br><span class="line"><span class="attr">caps_h</span>=keyFunc_moveLeft</span><br><span class="line"><span class="attr">caps_l</span>=keyFunc_moveRight</span><br><span class="line"><span class="attr">caps_b</span>=keyFunc_moveWordLeft</span><br><span class="line"><span class="attr">caps_w</span>=keyFunc_moveWordRight</span><br><span class="line"><span class="attr">caps_o</span>=keyFunc_home</span><br><span class="line"><span class="attr">caps_p</span>=keyFunc_End</span><br><span class="line"><span class="attr">caps_x</span>=keyFunc_delete</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://github.com/wo52616111/capslock-plus">wo52616111&#x2F;capslock-plus</a></li>
<li><a href="https://capslox.com/capslock-plus/">Capslock+</a></li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>Capslock+</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA-Installation</title>
    <url>/post/a1962535.html</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul>
<li>Version：2020.3</li>
<li>官网：<a href="https://www.jetbrains.com/idea/download/other.html">https://www.jetbrains.com/idea/download/other.html</a></li>
</ul>
<h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h2><ul>
<li>BetterIntelliJ：<a href="https://chrisgray.oss-cn-beijing.aliyuncs.com/Archive/BetterIntelliJ.zip">https://chrisgray.oss-cn-beijing.aliyuncs.com/Archive/BetterIntelliJ.zip</a></li>
</ul>
<h2 id="试用勾选"><a href="#试用勾选" class="headerlink" title="试用勾选"></a>试用勾选</h2><ul>
<li>Evaluate for free</li>
<li>Evaluate</li>
</ul>
<h2 id="插件导入"><a href="#插件导入" class="headerlink" title="插件导入"></a>插件导入</h2><ul>
<li>File-Settings-Plugins-Install Plugin From Disk</li>
</ul>
<h3 id="插件确认"><a href="#插件确认" class="headerlink" title="插件确认"></a>插件确认</h3><ul>
<li><p>idea64.exe.vmoptions</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-javaagent:C:\Users\Public\.BetterIntelliJ\BetterIntelliJ-1.15.jar</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="IDE重启"><a href="#IDE重启" class="headerlink" title="IDE重启"></a>IDE重启</h2><ul>
<li>必须重启</li>
</ul>
<h2 id="激活码输入"><a href="#激活码输入" class="headerlink" title="激活码输入"></a>激活码输入</h2><ul>
<li><p>Activation Code：</p>
<p><code>BISACXYELK-eyJsaWNlbnNlSWQiOiJCSVNBQ1hZRUxLIiwibGljZW5zZWVOYW1lIjoiQ2hpbmFOQiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNGIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUkIiLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRQIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjAwNzI4RVBKQTAwODAwNiIsImhhc2giOiIxNTAyMTM1NC8wOi0xMjUxMTE0NzE3IiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-H7NUmWcLyUNV1ctnlzc4P79j15qL56G0jeIYWPk/HViNdMg1MqPM7BR+aHR28yyuxK7Odb2bFDS8CeHNUtv7nT+4fUs85JJiqc3wc1psRpZq5R77apXLOmvmossWpbAw8T1hOGV9IPUm1f2O1+kLBxrOkdqPpv9+JanbdL7bvchAid2v4/dyQMBYJme/feZ0Dy2l7Jjpwno1TeblEAu0KZmarEo15or5RUNwtaGBL5+396TLhnw1qL904/uPnGftjxWYluLjabO/uRu/+5td8UA/39a1nvGU2nORNLk2IdRGIheiwIiuirAZrII9+OxB+p52i3TIv7ugtkw0E3Jpkw==-MIIDlzCCAn+gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1KZXRQcm9maWxlIENBMCAXDTE4MTEwMTEyMjk0NloYDzIwOTkwODA5MDIyNjA3WjBoMQswCQYDVQQGEwJDWjEOMAwGA1UECBMFTnVzbGUxDzANBgNVBAcTBlByYWd1ZTEZMBcGA1UEChMQSmV0QnJhaW5zIHMuci5vLjEdMBsGA1UEAxMUcHJvZDN5LWZyb20tMjAxODExMDEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCdXyaNhhRySH1a8d7c8SlLLFdNcQP8M3gNnq7gudcpHC651qxRrN7Qks8gdXlIkA4u3/lp9ylp95GiIIDo4ydYje8vlTWDq02bkyWW/G7gZ3hkbBhRUK/WnNyr2vwWoOgwx5CfTRMjKkPkfD/+jffkfNfdGmGcg9yfnqPP9/AizKzWTsXSeS+0jZ8Nw5tiYFW+lpceqlzwzKdTHug7Vs0QomUPccRtZB/TBBEuiC7YzrvLg4Amu0I48ETAcch/ztt00nx/oj/fu1DTnz4Iz4ilrNY+WVIEfDz/n3mz+PKI9kM+ZeB0jAuyLsiC7skGpIVGX/2HqmZTtJKBZCoveAiVAgMBAAGjgZkwgZYwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TAJBgNVHRMEAjAAMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAsGA1UdDwQEAwIFoDAdBgNVHQ4EFgQUYSkb2hkZx8swY0GRjtKAeIwaBNwwDQYJKoZIhvcNAQELBQADggEBAJZOakWgjfY359glviVffBQFxFS6C+4WjYDYzvzjWHUQoGBFKTHG4xUmTVW7y5GnPSvIlkaj49SzbD9KuiTc77GHyFCTwYMz+qITgbDg3/ao/x/be4DD/k/byWqW4Rb8OSYCshX/fNI4Xu+hxazh179taHX4NaH92ReLVyXNYsooq7mE5YhR9Qsiy35ORviQLrgFrMCGCxT9DWlFBuiPWIOqN544sL9OzFMz+bjqjCoAE/xfIJjI7H7SqGFNrx/8/IuF0hvZbO3bLIz+BOR1L2O+qT728wK6womnp2LLANTPbwu7nf39rpP182WW+xw2z9MKYwwMDwGR1iTYnD4/Sjw=</code></p>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://www.jb51.net/article/204399.htm">IDEA 2020.3最新永久激活码(免费激活到 2099 年,亲测有效)_java_脚本之家 (jb51.net)</a></li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>IDEA</category>
      </categories>
  </entry>
  <entry>
    <title>Jupyter Notebook-Installation</title>
    <url>/post/1247f3dd.html</url>
    <content><![CDATA[<blockquote>
<p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。</p>
</blockquote>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="通过-pip-安装"><a href="#通过-pip-安装" class="headerlink" title="通过 pip 安装"></a>通过 pip 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>

<h2 id="通过-Anaconda-安装"><a href="#通过-Anaconda-安装" class="headerlink" title="通过 Anaconda 安装"></a>通过 Anaconda 安装</h2><ul>
<li>Anaconda 已自动安装 Jupyter NoteBook</li>
</ul>
<h3 id="Anaconda-下载"><a href="#Anaconda-下载" class="headerlink" title="Anaconda 下载"></a>Anaconda 下载</h3><ul>
<li>Anaconda 官网：<a href="https://www.anaconda.com/products/distribution">Anaconda | Anaconda Distribution</a></li>
</ul>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install jupyter notebook</span><br></pre></td></tr></table></figure>

<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<h2 id="指定端口启动"><a href="#指定端口启动" class="headerlink" title="指定端口启动"></a>指定端口启动</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">jupyter notebook --port &lt;port_number&gt;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/33105153">Jupyter Notebook介绍、安装及使用教程 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>Jupyter Notebook</category>
      </categories>
  </entry>
  <entry>
    <title>Jupyter Notebook-Configuration</title>
    <url>/post/e1e8753d.html</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="文件地址查找"><a href="#文件地址查找" class="headerlink" title="文件地址查找"></a>文件地址查找</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>

<h2 id="默认工作目录修改"><a href="#默认工作目录修改" class="headerlink" title="默认工作目录修改"></a>默认工作目录修改</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir = &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="Conda-环境关联"><a href="#Conda-环境关联" class="headerlink" title="Conda 环境关联"></a>Conda 环境关联</h1><h2 id="nb-conda-安装"><a href="#nb-conda-安装" class="headerlink" title="nb_conda 安装"></a>nb_conda 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install nb_conda</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>重启后可在主页找到 <code>Conda</code> 标签</li>
<li>可在每一个 Notebook 中通过 <code>Kernel</code> 条目下的 <code>Change kernel</code> 切换运行环境</li>
</ul>
<h1 id="Nbextensions-插件配置"><a href="#Nbextensions-插件配置" class="headerlink" title="Nbextensions 插件配置"></a>Nbextensions 插件配置</h1><h2 id="Nbextensions-安装"><a href="#Nbextensions-安装" class="headerlink" title="Nbextensions 安装"></a>Nbextensions 安装</h2><ul>
<li>官网：<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/install.html">Installing jupyter_contrib_nbextensions — jupyter_contrib_nbextensions 0.5.0 documentation (jupyter-contrib-nbextensions.readthedocs.io)</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line">jupyter contrib nbextension install --user <span class="comment"># Install javascript and css files</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul>
<li>重启后可在主页找到 <code>Nbextensions</code> 标签</li>
</ul>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ul>
<li>Code prettify</li>
<li>Collapsible Headings</li>
<li>highlighter</li>
<li>Hinterland</li>
<li>Scratchpad</li>
<li>Table of Contents (2)</li>
</ul>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><h2 id="jupyterthemes-安装"><a href="#jupyterthemes-安装" class="headerlink" title="jupyterthemes 安装"></a>jupyterthemes 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterthemes</span><br></pre></td></tr></table></figure>

<h2 id="主题列表查看"><a href="#主题列表查看" class="headerlink" title="主题列表查看"></a>主题列表查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jt -l</span><br></pre></td></tr></table></figure>

<h2 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jt -t &lt;theme_name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="默认主题恢复"><a href="#默认主题恢复" class="headerlink" title="默认主题恢复"></a>默认主题恢复</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jt -r</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>可自定义字体、样式、宽度、占屏比等</li>
<li>或与 Nbextensions <strong>插件不兼容</strong></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/166165379">泣血整理，Jupyter Notebook最常用的五大配置技巧 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33105153">Jupyter Notebook介绍、安装及使用教程 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_44015669/article/details/104975271">给！最详版的Jupyter NBextensions 插件介绍_哆啦A梦_i的博客-CSDN博客_jupyter nbextension</a></li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>Jupyter Notebook</category>
      </categories>
  </entry>
  <entry>
    <title>Maven-HTTP Blocked</title>
    <url>/post/d9735be4.html</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote>
<p>Could not transfer artifact xxx from&#x2F;to maven-default-http-blocker (<a href="http://0.0.0.0/">http://0.0.0.0/</a>):<br>Blocked mirror for repositories: [blocked-repository-id (<a href="http://blocked.repository.org/">http://blocked.repository.org</a>, default, releases+snapshots)]</p>
</blockquote>
<ul>
<li>Maven 在升级到 3.8.1 以后，从安全角度考虑，默认将非 HTTPS 的远端仓库屏蔽掉了。</li>
</ul>
<span id="more"></span>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li><p>将 Maven 版本降到 3.8.1 以下</p>
</li>
<li><p>让远端仓库支持 HTTPS</p>
</li>
<li><p>为每一个 HTTP 源增加 mirror 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>other-mirror<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Other Mirror Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://other-mirror.repo.other-company.com/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释 <code>$MAVEN_HOME/conf/settings.xml</code> 默认配置中的相关镜像配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default-http-blocker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:http:*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://0.0.0.0/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>~/.m2/settings.xml</code> 配置中使用 dummy 镜像覆盖默认配置中的镜像配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default-http-blocker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:dummy:*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://0.0.0.0/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://blog.csdn.net/loushuai/article/details/124182904">Maven “Blocked mirror for repositories” 错误解决办法_Code Talk的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://maven.apache.org/docs/3.8.1/release-notes.html">Maven – Release Notes – Maven 3.8.1 (apache.org)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Typora-Config</title>
    <url>/post/aff035cd.html</url>
    <content><![CDATA[<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><ul>
<li>启动选项：重新打开上次使用的文件和目录</li>
<li>保存 &amp; 恢复<ul>
<li><input checked="" disabled="" type="checkbox"> 自动保存</li>
</ul>
</li>
</ul>
<h1 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h1><ul>
<li><p>字体大小：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 自定义15px</li>
</ul>
</li>
<li><p>主题：<a href="https://github.com/liangjingkanji/DrakeTyporaTheme">Drake Purple</a></p>
<ul>
<li>样式调整</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2.4rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><ul>
<li><p>使用成对的括号：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 匹配括号和引号</li>
<li><input checked="" disabled="" type="checkbox"> 匹配 Markdown 字符</li>
</ul>
</li>
<li><p>拼写检查：不使用拼写检查</p>
</li>
</ul>
<h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><ul>
<li>插入图片时：上传图片<ul>
<li><input checked="" disabled="" type="checkbox"> 对本地位置的图片应用上述规则</li>
<li><input checked="" disabled="" type="checkbox"> 对网络位置的图片应用上述规则</li>
</ul>
</li>
<li>上传服务设定：PicGo(app)</li>
</ul>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><ul>
<li><p><input checked="" disabled="" type="checkbox"> 
严格模式</p>
</li>
<li><p>有序列表：1. ··· 1. ···</p>
</li>
<li><p>Markdown 扩展语法：全部勾选</p>
</li>
<li><p>代码块：全部勾选</p>
</li>
<li><p>公式：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 自动添加序号</li>
<li><input checked="" disabled="" type="checkbox"> 支持使用 \\ 和 \newline 换行</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>Typora</category>
      </categories>
  </entry>
  <entry>
    <title>Typora-Installation</title>
    <url>/post/bb5ae20b.html</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul>
<li><p>官方中文站：<a href="https://typoraio.cn/">https://typoraio.cn/</a></p>
</li>
<li><p>官网：<a href="https://www.typora.io/">https://www.typora.io/</a></p>
</li>
</ul>
<h1 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h1><ul>
<li>官方商城：<a href="https://secure.2checkout.com/order/checkout.php?PRODS=37673796&amp;QTY=1&amp;CART=1&amp;SHORT_FORM=1&amp;ORDERSTYLE=nLWw45S5pnE=&amp;CARD=2&amp;CURRENCY=CNY&amp;LANGUAGES=zh&amp;PAY_TYPE=WE_CHAT_PAY&amp;__c=1">https://secure.2checkout.com/order/checkout.php?PRODS=37673796&amp;QTY=1&amp;CART=1&amp;SHORT_FORM=1&amp;ORDERSTYLE=nLWw45S5pnE%3D&amp;CARD=2&amp;CURRENCY=CNY&amp;LANGUAGES=zh&amp;PAY_TYPE=WE_CHAT_PAY&amp;__c=1</a></li>
<li>独家代理：<a href="https://store.lizhi.io/site/products/id/520?cid=lpuwt9hw">https://store.lizhi.io/site/products/id/520?cid=lpuwt9hw</a></li>
</ul>
<h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><ul>
<li>app.asar：<a href="https://chrisgray.oss-cn-beijing.aliyuncs.com/Archive/app.asar">https://chrisgray.oss-cn-beijing.aliyuncs.com/Archive/app.asar</a></li>
</ul>
<h2 id="文件覆盖"><a href="#文件覆盖" class="headerlink" title="文件覆盖"></a>文件覆盖</h2><ul>
<li>将下载好的 app.asar 覆盖至应用目录下的 resources 文件夹内的同名文件。</li>
</ul>
<h2 id="序列号输入"><a href="#序列号输入" class="headerlink" title="序列号输入"></a>序列号输入</h2><ul>
<li>打开应用，输入序列号<ul>
<li>DZTX2H-6MCQZT-QL4GCT-5EBWFX</li>
<li>G7LPKN-HP4NLD-FA3BGF-6JDQ5R</li>
<li>3MH4Y8-YJWT37-G5JL9Y-UHNQDJ</li>
<li>85ZPHY-ELQ9FQ-94J3VP-D92YLU</li>
<li>VEZ7NV-USYN3G-8TL2N3-DADUG4</li>
</ul>
</li>
<li>邮箱可任意填写（须保证格式正确）</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://www.cnblogs.com/xiaohi/p/15907083.html">Typora（morkdown编辑器）的下载和破解 - article - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>Typora</category>
      </categories>
  </entry>
  <entry>
    <title>iTerm2</title>
    <url>/post/10a3695f.html</url>
    <content><![CDATA[<blockquote>
<p>iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with macOS 10.14 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.</p>
</blockquote>
<span id="more"></span>

<h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p><a href="https://iterm2.com/index.html">iTerm2 - macOS Terminal Replacement</a></p>
<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><h2 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h2><ul>
<li>Make iTerm2 default term</li>
</ul>
<h2 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h2><ul>
<li>Shortcut Key: Profiles - General</li>
<li>Transparency: Profiles - Window</li>
<li>Status Bar: Profiles - Session - Configure Status Bar</li>
<li>Save Profile: Profiles - Other Actions</li>
</ul>
<h1 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h1><p><a href="https://ohmyz.sh/">Oh My Zsh - a delightful &amp; open source framework for Zsh</a></p>
<h2 id="Installation-1"><a href="#Installation-1" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Font"><a href="#Font" class="headerlink" title="Font"></a>Font</h2><p><a href="https://cdn.jsdelivr.net/gh/powerline/fonts/Meslo%20Slashed/Meslo%20LG%20S%20Regular%20for%20Powerline.ttf">Meslo LG S Regular for Powerline</a></p>
<h2 id="Configuration-1"><a href="#Configuration-1" class="headerlink" title="Configuration"></a>Configuration</h2><ul>
<li>Directory: <code>.oh-my-zsh</code></li>
</ul>
<h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><ul>
<li>Recommand<ul>
<li>agnoster</li>
</ul>
</li>
<li>Configuration: <code>~/.zshrc</code></li>
<li>Configure: <code>ZSH_THEME=</code></li>
<li>Random: <code>ZSH_THEME_RANDOM_CANDIDATES=()</code></li>
</ul>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><ul>
<li>Recommand<ul>
<li>zsh-autosuggestions</li>
<li>zsh-syntax-highlighting</li>
</ul>
</li>
<li>Configuration: <code>~/.zshrc</code></li>
<li>Configure: <code>plugins=()</code></li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
        <category>iTerm2</category>
      </categories>
  </entry>
  <entry>
    <title>Data Warehouse</title>
    <url>/post/2bcbefa4.html</url>
    <content><![CDATA[<p>Data Warehouse（DW），顾名思义，是一个很大的数据存储集合，出于企业的分析性报告和决策支持目的而创建，对多样的业务数据进行筛选与整合。它为企业提供一定的BI(商业智能)能力，指导业务流程改进、监视时间、成本、质量以及控制。</p>
<span id="more"></span>

<h2 id="业务痛点"><a href="#业务痛点" class="headerlink" title="业务痛点"></a>业务痛点</h2><ol>
<li>无法应对频繁临时需求</li>
<li>数据资产模糊</li>
<li>数据质量低</li>
<li>重复建设</li>
<li>代码耦合性高</li>
<li>问题难定位，周期长</li>
</ol>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>面向主题（Subject Oriented）</p>
</li>
<li><p>集成（Integrate）</p>
</li>
<li><p>非易失（Non-Volatile）</p>
</li>
<li><p>反映历史变化（Time Variant）</p>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="联机事务处理（OLTP）"><a href="#联机事务处理（OLTP）" class="headerlink" title="联机事务处理（OLTP）"></a>联机事务处理（OLTP）</h3><p>（On-Line Transaction Processing），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发的支持用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。</p>
<h3 id="联机分析处理（OLAP）"><a href="#联机分析处理（OLAP）" class="headerlink" title="联机分析处理（OLAP）"></a>联机分析处理（OLAP）</h3><p>（On-Line Analytical Processing）一般针对某些主题历史数据进行分析，支持管理决策。</p>
<h2 id="架构（OneData）"><a href="#架构（OneData）" class="headerlink" title="架构（OneData）"></a>架构（OneData）</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>三特性：统一性、唯一性和规范性</li>
<li>三效果：高扩展性、强复用性和低成本性</li>
</ul>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul>
<li>统一归口</li>
<li>统一出口</li>
</ul>
<h3 id="ODS-Operation-Data-Store-，操作数据层"><a href="#ODS-Operation-Data-Store-，操作数据层" class="headerlink" title="ODS(Operation Data Store)，操作数据层"></a>ODS(Operation Data Store)，操作数据层</h3><p>数据仓库准备区，为DWD层提供基础原始数据，可减少对业务系统的影响。</p>
<p>建模方式及原则：</p>
<ol>
<li>从业务系统增量抽取</li>
<li>保留时间由业务需求决定</li>
<li>可分表进行周期存储</li>
<li>数据不做清洗转换与业务系统数据模型保持一致</li>
<li>按主题逻辑划分</li>
</ol>
<h3 id="DWD-Data-Warehouse-Detail-，明细粒度事实层"><a href="#DWD-Data-Warehouse-Detail-，明细粒度事实层" class="headerlink" title="DWD(Data Warehouse Detail)，明细粒度事实层"></a>DWD(Data Warehouse Detail)，明细粒度事实层</h3><p>为DW层提供来源明细数据，提供业务系统细节数据的长期沉淀，为未来分析类需求的扩展提供历史数据支撑。</p>
<p>通常分为三种：事务事实表、周期快照事实表和累积快照事实表。</p>
<ul>
<li><p>事务事实表用来描述业务过程，跟踪空间或时间上某点的度量事件，保存的是最原子的数据，也称为原子事实表。</p>
</li>
<li><p>周期快照事实表以具有规律性的、可预见的时间间隔记录事实。</p>
</li>
<li><p>累积快照事实表用来表述过程开始和结束之间的关键步骤事件，覆盖过程的整个生命周期，通常具有多个日期字段来记录关键时间点。当累积快照事实表随着生命周期不断变化时，记录也会随着过程的变化而被修改。</p>
</li>
</ul>
<h3 id="DWT（Data-Warehouse-Topic），主题宽表层"><a href="#DWT（Data-Warehouse-Topic），主题宽表层" class="headerlink" title="DWT（Data Warehouse Topic），主题宽表层"></a>DWT（Data Warehouse Topic），主题宽表层</h3><p>对DWD各信息进行关联整合，输出主题宽表（面向业务过程，不同业务过程的信息不冗余建设，采用外键形式）。</p>
<h3 id="DWS-Data-Warehouse-Summary-，公共汇总粒度事实层"><a href="#DWS-Data-Warehouse-Summary-，公共汇总粒度事实层" class="headerlink" title="DWS(Data Warehouse Summary)，公共汇总粒度事实层"></a>DWS(Data Warehouse Summary)，公共汇总粒度事实层</h3><p>为DW层提供细粒度数据，DWS按各个维度ID进行粗粒度汇总聚合，如按交易来源，交易类型进行汇合 。</p>
<p>建模方式及原则：</p>
<ol>
<li>聚合、汇总增加派生事实；</li>
<li>关联其它主题的事实表，DW层可能会跨主题域；</li>
<li>保持高粒度汇总数据；</li>
<li>数据模型可能采用反范式设计，合并信息等。</li>
</ol>
<h3 id="ADS-Application-Data-Store-，应用数据层"><a href="#ADS-Application-Data-Store-，应用数据层" class="headerlink" title="ADS(Application Data Store)，应用数据层"></a>ADS(Application Data Store)，应用数据层</h3><p>ADS层面向用户应用和分析需求，包括前端报表、分析图表、KPI、仪表盘、OLAP、专题等分析，面向最终结果用户；适合作OLAP、报表模型；根据DW层经过聚合汇总统计后的粗粒度事实表 </p>
<p>建模方式及原则：</p>
<ol>
<li>保持数据量小；</li>
<li>维度建模，星形模型；</li>
<li>各位维度代理键+度量；</li>
<li>增加数据业务日期字段，支持数据重跑；</li>
<li>不分表存储</li>
</ol>
<h3 id="DIM，维度层"><a href="#DIM，维度层" class="headerlink" title="DIM，维度层"></a>DIM，维度层</h3><p>建立一致数据分析维表，可以降低数据计算口径和算法不统一风险。</p>
<p>以维度作为建模驱动，基于每个维度的业务含义，通过定义维度及维度主键，添加维度属性、关联维度等定义计算逻辑和雪花模型，完成属性定义的过程并建立一致的数据分析维表。</p>
<p>同时您可以定义维度主子关系，子维度的属性将合并至主维度使用，进一步保证维度的一致性和便捷使用性。</p>
<p>建模方式及原则：</p>
<ol>
<li>尽可能生成丰富的维度属性。</li>
<li>尽可能多的给出包含一些富有意义的文字性描述。</li>
<li>区分数值型属性和事实。</li>
<li>尽量沉淀出通用的维度属性。</li>
</ol>
<h2 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h2><ol>
<li>所有表中的数据都为原子数据，不可再分</li>
<li>所有表中的所有字段都必须依赖主关键字</li>
<li>所有表中的非主关键词之间不能函数依赖关系</li>
</ol>
<h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>在关系模式R中的每一个具体关系r中，必须要有主键,并且每个属性值 都是不可再分的最小数据单位，则称R是第一范式的关系。</p>
<h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>如果关系模式R中的所有非主属性都完全依赖于主关键字，则称关系R 是属于第二范式的。 </p>
<h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>关系模式R中的非主关键字不能依赖于其他非主关键字。即非主关键字之间不能有函数（传递）依赖关系。则称关系R是属于第三范式的。</p>
<h2 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h2><p>维度建模是一种将数据结构化的逻辑设计方法，它将客观世界划分为度量和上下文。</p>
<p>度量是常常是以数值形式出现，事实周围有上下文包围着，这种上下文被直观地分成独立的逻辑块，称之为维度。</p>
<p>实体-关系建模是面向应用，遵循第三范式，以消除数据冗余为目标的设计技术。</p>
<p>维度建模是面向分析，为了提高查询性能可以增加数据冗余，反规范化的设计技术。</p>
<p>用于度量的事实表，事实表一般会有两个或者多个外健与维度表的主键进行关联。事实表的主键一般是组合健，表达多对多的关系。</p>
<p>用于描述环境的维度表，单一主键，维度表的属性是所有查询约束和报表标示的来源。维度提供数据的入口点，提供所有DW&#x2F;BI分析的最终标识和分组。</p>
<p>所以维度建模表示每个业务过程包含的事实表，事实表里面存储事件的数值化度量，围绕事实表的是多个维度表，维度表包含事件发生的实际存在的文本环境。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>便于理解</li>
<li>提高查询性能</li>
<li>对称性</li>
<li>可扩展性</li>
</ol>
<h3 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h3><p>事实表存储了从业务活动或事件提炼出来的性能度量，它主要包含维度表的外键和连续变化的可加性数值或半可加事实。事实表产生于业务过程中而不是业务过程的描述性信息。它一般是行多列少，占了数据仓库的90%的空间。在维度模型中也有表示多对多关系的事实，其他都是维度表。 </p>
<h3 id="事务事实表"><a href="#事务事实表" class="headerlink" title="事务事实表"></a>事务事实表</h3><p> 它是面向事务的，其粒度是每一行对应一个事务，它是最细粒度的事实表。</p>
<h3 id="周期快照事实表"><a href="#周期快照事实表" class="headerlink" title="周期快照事实表"></a>周期快照事实表</h3><p>它是按照良好的时间周期间隔(每天，每月)来捕捉业务活动的执行情况，一旦装入事实表就不会再去更新，它是事务事实表的补充，而非替代品。</p>
<h3 id="累积快照事实表"><a href="#累积快照事实表" class="headerlink" title="累积快照事实表"></a>累积快照事实表</h3><p>它用于描述业务过程中某个不确定时间跨度里的活动，它随着业务活动的发生会不断的更新。</p>
<h3 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h3><p>维度表是对业务过程的上下文描述，主要包含代理键、文本信息和离散的数字。</p>
<p>它是进入事实表的入口，丰富的维度属性给出了对事实表的分析切割能力，它一般是行少列多。</p>
<p>如果属性值是离散的，用于过滤和标记的，就放到维度表里，如果是属性值是连续取值，用于计算的，就放到事实表中。</p>
<h3 id="星型模型"><a href="#星型模型" class="headerlink" title="星型模型"></a>星型模型</h3><p>一种多维的数据关系，它由一个事实表（Fact Table）和一组维表（Dimension  Table）组成。</p>
<p>每个维表都有一个维作为主键，所有这些维的主键组合成事实表的主键。</p>
<p>事实表的非主键属性称为事实（Fact），它们一般都是数值或其他可以进行计算的数据。</p>
<h3 id="雪花模型"><a href="#雪花模型" class="headerlink" title="雪花模型"></a>雪花模型</h3><p>当有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上时，其图解就像多个雪花连接在一起，故称雪花模型。</p>
<p>雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的 “层次 “ 区域，这些被分解的表都连接到主维度表而不是事实表。</p>
<p>通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。雪花型结构去除了数据冗余。</p>
<h3 id="星型模型VS雪花模型"><a href="#星型模型VS雪花模型" class="headerlink" title="星型模型VS雪花模型"></a>星型模型VS雪花模型</h3><h4 id="查询性能"><a href="#查询性能" class="headerlink" title="查询性能"></a>查询性能</h4><p>OLTP-DW环节，由于雪花型要做多个表联接，性能会低于星型架构；</p>
<p>DW-OLAP环节，由于雪花型架构更有利于度量值的聚合，因此性能要高于星型架构。</p>
<h4 id="模型复杂度"><a href="#模型复杂度" class="headerlink" title="模型复杂度"></a>模型复杂度</h4><p>星型架构更简单方便处理。</p>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p>雪花型架构更加贴近OLTP系统的结构，比较符合业务逻辑，层次比较清晰。</p>
<h4 id="存储角度"><a href="#存储角度" class="headerlink" title="存储角度"></a>存储角度</h4><p>雪花型架构具有关系数据模型的所有优点，不会产生冗余数据。</p>
<p>星型架构会产生数据冗余。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般建议使用星型模型。因为在实际项目中，往往最关注的是查询性能问题，至于磁盘空间一般都不是问题。</p>
<p>在维度表数据量极大，需要节省存储空间的情况下，或者是业务逻辑比较复杂、必须要体现清晰的层次概念情况下，可以使用雪花型模型。</p>
<h2 id="宽表"><a href="#宽表" class="headerlink" title="宽表"></a>宽表</h2><p>宽表从字面意义上讲就是字段比较多的数据库表。通常是指业务主题相关的指标、维度、属性关联在一起的一张数据库表。</p>
<p>由于把不同的内容都放在同一张表存储，宽表已经不符合三范式的模型设计规范，随之带来的主要坏处就是数据的大量冗余，与之相对应的好处就是查询性能的提高与便捷。</p>
<p>这种宽表的设计广泛应用于数据挖掘模型训练前的数据准备，通过把相关字段放在同一张表中，可以大大提高数据挖掘模型训练过程中迭代计算时的效率问题。</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>Consistency，Availability和Partition Tolerance，理论认为数据一致性（C）、系统可用性（A）和网络分区容忍性（P），在系统中的任何时刻三个性质中只能同时保证两个性质成立，而网络常常又是不可靠的。</p>
<h3 id="数据一致性模型"><a href="#数据一致性模型" class="headerlink" title="数据一致性模型"></a>数据一致性模型</h3><p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器。</p>
<p>由于维护数据副本的一致性代价高，因此许多系统采用弱一致性来提高性能。</p>
<p>强一致性： 要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。</p>
<p>弱一致性：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</p>
<p>最终一致性：是弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。</p>
<h2 id="元数据管理"><a href="#元数据管理" class="headerlink" title="元数据管理"></a>元数据管理</h2><h2 id="数据质量的评估"><a href="#数据质量的评估" class="headerlink" title="数据质量的评估"></a>数据质量的评估</h2>]]></content>
      <categories>
        <category>Tech</category>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase</title>
    <url>/post/ef636ad6.html</url>
    <content><![CDATA[<p>分布式、面向列的数据存储系统，通过在HDFS上提供随机读&#x2F;写来解决Hadoop不能解决的问题。</p>
<p>为了高可用性牺牲了一部分的一致性。</p>
<span id="more"></span>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>没有真正的索引，行是顺序存储的，每行中的列也是，不存在索引膨胀问题，插入性能和表的大小无关。</p>
<p>自动分区，在表增长的时候，表会自动分裂成区域，并分布到可用的节点上。</p>
<p>线性扩展和对新节点的自动处理，增加一个节点，把它指向现有集群并运行regionserver，区域自动重新进行平衡，负载均匀分布。</p>
<p>廉价，普通商用硬件支持。</p>
<p>容错，大量节点意味每个节点的重要性并不突出，不用担心单个节点失效。</p>
<p>批处理，Mapreduce集成功能使我们可以用全并行的分布式作业根据“数据的位置”来处理它们。</p>
<p>管理超大规模的稀疏表，对于为null的列，并不占用存储空间。</p>
<h2 id="与RDBMS异同"><a href="#与RDBMS异同" class="headerlink" title="与RDBMS异同"></a>与RDBMS异同</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>RDBMS采用关系模型，具有丰富的数据类型和存储方式；</p>
<p>HBase采用简单的数据模型，将数据存储为未解释的字符数组，所有数据都没有类型，都直接作为字符数组来看待。</p>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>关系型数据库有丰富的数据操作，并且涉及复杂的多表连接；</p>
<p>HBase操作不存在复杂的表与表之间的连接关系，只有简单的插入、查询、删除、清空等操作，因为HBase在设计上就避免了复杂的表和表之间的关系。</p>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>RDBMS基于行模式存储；</p>
<p>HBase基于列模式存储，每个列族的数据都保存在一起，不同列族的文件是相互分离的。</p>
<h3 id="数据索引"><a href="#数据索引" class="headerlink" title="数据索引"></a>数据索引</h3><p>RDBMS中，有模式、表、视图、索引等多个概念，RDBMS可以根据不同列构建复杂的多个索引，以此来提高数据访问的性能；</p>
<p>HBase实际上只有一个索引——行键（Row Key），表的所有访问都要通过行键，或者通过行键访问，或者通过行键扫描。</p>
<h3 id="数据维护"><a href="#数据维护" class="headerlink" title="数据维护"></a>数据维护</h3><p>RDBMS中，更新操作会用当前的最新值去替换记录中的旧值，旧值被覆盖后就不再存在了；</p>
<p>HBase中的每个单元格是有一个以时间戳表示的版本号的，它在执行更新操作时，并不会删除数据的旧版本，而是生成一个具有更新的版本号的新数据，原有旧数据仍然会保存。</p>
<h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p>RDBMS大多受限于一台机器的存储容量，只能进行垂直扩展（更换大容量的设备、提升设备性能等等），很难做到横向扩展；</p>
<p>HBase设计的初衷本来是为了实现灵活的横向扩展，能够通过简单的增加节点数量来实现扩展，从而可以存储超大规模数据集，实现超大规模数据的随机访问。</p>
<h2 id="扫描机制"><a href="#扫描机制" class="headerlink" title="扫描机制"></a>扫描机制</h2><p>调用HTable的getScanner()方法，返回扫描器(scanner)实例。</p>
<p>可以选择提供起始行和终止行行键。</p>
<p>可以选择使用过滤器(filter)。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Tech</category>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop-HDFS</title>
    <url>/post/39223cc.html</url>
    <content><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>不支持并发写入</li>
<li>不支持文件当随机修改，仅支持数据追加（append）</li>
</ul>
<span id="more"></span>

<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h2><ul>
<li>守护进程，负责维护整个文件系统，存储着整个文件系统的<strong>元数据信息</strong>，管理命名空间</li>
<li>配置副本策略（？</li>
<li>管理数据块（block）映射信息</li>
<li>处理读写请求</li>
<li>其中镜像备份 <code>Fsimage</code> 和 日志备份 <code>Edit.log</code> 的内容 namenode 不会持久化存储，而是在启动时重建这些数据</li>
</ul>
<h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><ul>
<li>具体工作节点，存储实际的数据块</li>
<li>执行数据块的读写操作</li>
</ul>
<h2 id="SecondaryNameNode"><a href="#SecondaryNameNode" class="headerlink" title="SecondaryNameNode"></a>SecondaryNameNode</h2><ul>
<li>主要负责定期合并 <code>Fsimage</code> 和 <code>Edit.log</code>，并推送给 NameNode</li>
<li>在紧急情况下，可辅助恢复 NameNode</li>
</ul>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><ul>
<li>文件切分</li>
<li>节点交互</li>
</ul>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul>
<li><p>Namespace 限制：由于 NameNode 在内存中存储所有的元数据，因此单个 NameNode 所能存储的对象（文件+块）数目受到 NameNode 所在 JVM 的 heap size 的限制。</p>
</li>
<li><p>隔离问题：由于仅有一个 NameNode，无法隔离各个程序，因此 HDFS 上的一个实验程序就很有可能影响整个 HDFS 上运行的程序。</p>
</li>
<li><p>性能问题：由于仅有一个 NameNode，整个 HDFS 的吞吐量受限于单个 NameNode 的吞吐量。</p>
</li>
</ul>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><ul>
<li>物理上分块存储</li>
<li><code>dfs.blocksize</code> &#x3D; 64M</li>
<li>最佳配置：寻址时间为传输时间的 1%；块的设置取决于<strong>磁盘传输速率</strong></li>
<li>块设置过小，会增加寻址时间；块设置过大，传输时间过久</li>
</ul>
<h1 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h1><ol>
<li>Client 与 NameNode 建立连接，创建文件元数据信息</li>
<li>NameNode 判断元数据是否有效</li>
<li>NameNode 触发副本存放策略，返回一个有序的 DataNode 列表</li>
<li>Client 与 DataNode 建立管道连接，Client 将文件块切成一个个 &#x3D;&#x3D;Packet&#x3D;&#x3D;</li>
<li>Client 将 Packet 放入管道并向第一个 DataNode 传输</li>
<li>第一个 DataNode 保存后发送给第二个 DataNode，第二个DataNode保存后以此类推</li>
<li>几个 DataNode 会与 NameNode 建立<strong>心跳</strong>，确认传输完成后完成写流程</li>
</ol>
<h2 id="副本节点选择"><a href="#副本节点选择" class="headerlink" title="副本节点选择"></a>副本节点选择</h2><ul>
<li>若 Client 在集群内，则第一个副本在其所处节点上， 否则随机选择一个节点</li>
<li>第二个副本选择与第一个所处相同机架的随机节点</li>
<li>第三个副本选择不同机架的随机节点</li>
</ul>
<h1 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h1><ol>
<li>Client 通过 &#x3D;&#x3D;Distribution File System&#x3D;&#x3D;与 NameNode 交互</li>
<li>NamdNode 通过查询元数据信息，获取文件块的位置，NameNode 会按照距离策略排序返回 &#x3D;&#x3D;DataNode 列表&#x3D;&#x3D;</li>
<li>Client 从最近的 DataNode 开始读，先建立管道，然后 DataNode 以 Packet为单位将数据传给 Client</li>
</ol>
<h1 id="元数据管理"><a href="#元数据管理" class="headerlink" title="元数据管理"></a>元数据管理</h1><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/4so1l1z2dy.png" alt="4so1l1z2dy"></p>
<p>采用内存 + 磁盘的方式进行元数据的管理：内存-&gt; NameNode，磁盘-&gt;Fsimage &amp; Edits。</p>
<ul>
<li>Fsimage：NameNode 中对元数据进行持久化存储生成的序列化文件，保存了最新的元数据检查点包含所有目录和文件索引。</li>
<li>Edits：记录Client 更新元数据信息的每一步操作，只进行追加操作，以日志的形式记录，保存自最新检查点后的命名空间的变化。</li>
</ul>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>NameNode 启动时，先滚动 Edits 并生成一个空的 <code>edits.inprogress</code>，然后加载 Edits 和 Fsimage 到内存中，此时 NameNode 内存就持有最新的元数据信息。</p>
<p>Client 开始对 NameNode 发送元数据的增删改的请求，这些请求的操作首先会被记录到 edits.inprogress 中，如果此时 NameNode 挂掉，重启后会从 Edits 中读取元数据的信息。然后，NameNode 会根据 Edits 按步执行。</p>
<p>由于 Edits 中记录的操作会越来越多，Edits 文件会越来越大，导致 NameNode 在启动加载 Edits 时会很慢，所以需要定期对 Edits 和 Fsimage 进行合并：将Edits 和 Fsimage 加载到内存中 ， 按照 Edits 按步执行 ， 最终形成新的 Fsimage。 </p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>启动 NameNode，创建&#x2F;直接加载 Fsimage 和 Edits</li>
<li>Client 对元数据进行增删改请求</li>
<li>NameNode 记录操作日志，更新 Edits</li>
<li>NameNode 在内存中对数据进行增删改</li>
<li>Secondary NameNode 询问 NameNode 是否需要 CheckPoint（触发 CheckPoint 需要满足两个条件中的任意一个，定时时间 1 h 到或 Edits 中数据已写满 64 M），并直接带回 NameNode 结果</li>
<li>Secondary NameNode 请求执行 CheckPoint</li>
<li>NameNode 滚动 Edits 并生成一个空的 edits.inprogress（滚动 Edits 的目的是给 Edits 打个标记，以后所有新的操作都写入 edits.inprogress），其他未合并的 Edits 和 Fsimag 会拷贝到 SecondaryNameNode</li>
<li>SecondaryNameNode 加载 Edits 和 Fsimage 加载到内存中进行合并，生成 <code>fsimage.chkpoint</code></li>
<li>拷贝 fsimage.chkpoint 到 NameNode</li>
<li>NameNode 将 fsimage.chkpoint 重新命名成 Fsimage</li>
</ol>
<h1 id="集群安全模式"><a href="#集群安全模式" class="headerlink" title="集群安全模式"></a>集群安全模式</h1><ul>
<li><p>集群处于安全模式，不能执行重要操作（写操作）。</p>
</li>
<li><p>集群启动完成后，自动退出安全模式。</p>
</li>
<li><p>在启动一个刚刚格式化的 HDFS集群时，因为系统中还没有任何块，所以 NameNode 不会进入安全模式。</p>
</li>
</ul>
<h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><ol>
<li>NameNode 启动：首先将 Fsimage 载入内存，并执行 Edits 中的各项操作。一旦在内存中成功建立文件系统元数据的映像，则创建一个新的 Fsimage 和一个空的Edits。此时，NameNode 开始监听 DataNode 请求。这个过程期间，NameNode 一直运行在安全模式，即 NameNode 的文件系统对于 Client 来说是只读的。 </li>
<li>DataNode 启动：在安全模式下，各个 DataNode 会向 NameNode 发送最新的块列表信息。</li>
<li>安全模式退出：判断如果满足“最小副本条件”，NameNode 会在30秒钟之后就退出安全模式。最小副本条件指的是在整个文件系统中 99.9% 的块满足最小副本级别（默认值：&#96;&#96;dfs.replication.min&#96; &#x3D; 1)。</li>
</ol>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h2><ul>
<li>一个数据块在 DataNode 上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据，包括数据块的长度，块数据的校验和，以及时间戳。 </li>
<li>DataNode 启动后向 NameNode 注册，通过后，周期性（1 小时）地向 NameNode 上报所有的块信息。</li>
<li>心跳每 3 秒一次，返回结果带有 NameNode 给该 DataNode 的命令。如果超过 10 分钟没有收到 DataNode 的心跳，则认为该节点不可用。</li>
<li>集群运行中可以安全加入和退出一些机器。</li>
</ul>
<h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><ul>
<li>（周期性）验证 <code>checkSum</code></li>
</ul>
<h2 id="掉线时限"><a href="#掉线时限" class="headerlink" title="掉线时限"></a>掉线时限</h2><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li>Timeout &#x3D; 2 * <code>dfs.namenode.hearteat.recheck-interval</code> + 10 * <code>dfs.hearteat.interval</code></li>
<li>dfs.namenode.hearteat.recheck-interval &#x3D; 300000 ms</li>
<li>dfs.hearteat.interval &#x3D; 3 s</li>
</ul>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><ul>
<li>通过双 NameNode 消除单点故障</li>
</ul>
<h2 id="工作要点"><a href="#工作要点" class="headerlink" title="工作要点"></a>工作要点</h2><ul>
<li>NameNode 各自存储一份元数据</li>
<li>Edits 日志只有 Active 状态的 NameNode 节点可以做写操作，两个 NameNode 都可以读取 Edits</li>
<li>共享的 Edits 放在一个共享存储中管理</li>
<li>需要一个状态管理功能模块，防止 <code>brain split</code> 的发生</li>
</ul>
<h2 id="自动故障转移工作机制"><a href="#自动故障转移工作机制" class="headerlink" title="自动故障转移工作机制"></a>自动故障转移工作机制</h2><ul>
<li>故障检测：集群中的每个 NameNode 在 ZooKeeper 中维护了一个持久会话，如果机器崩溃，ZooKeeper 中的会话将终止，ZooKeeper 会通知另一个 NameNode 需要触发故障转移。</li>
<li>现役 NameNode 选择：ZooKeeper 提供了一个简单的机制用于选择唯一的一个节点为 active 状态。如果现役 NameNode 崩溃，另一个节点可能从 ZooKeeper 获得特殊的排外锁以表明它应该成为现役 NameNode。</li>
</ul>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>ZKFC 是自动故障转移中的另一个新组件，是 ZooKeeper 的客户端，也监视和管理 NameNode 的状态。每个运行 NameNode 的主机也运行了一个 ZKFC 进程。</p>
<ul>
<li>健康监测：ZKFC 使用一个健康检查命令定期地 ping 与之在相同主机的 NameNode， 只要该 NameNode 及时地回复健康状态，ZKFC 认为该节点是健康的。如果该节点崩溃、冻结或进入不健康状态，将标识该节点为非健康的。</li>
<li>会话管理：当本地 NameNode 是健康的，ZKFC 保持一个在 ZooKeeper 中打开的会话。如果本地 NameNode 处于 active 状态，ZKFC 也保持一个特殊的 znode 锁， 该锁使用了 ZooKeeper 对短暂节点的支持，如果会话终止，锁节点将自动删除。 </li>
<li>基于 ZooKeeper 的 NameNode 选择：如果本地 NameNode 是健康的，且 ZKFC 发现没有其它的节点当前持有 znode 锁，它将为自己获取该锁。如果成功，则它将使本地的 NameNode 的状态为 Active 并负责运行故障转移进程。</li>
</ul>
<h3 id="假死"><a href="#假死" class="headerlink" title="假死"></a>假死</h3><p>同时出现两个 Active 状态的 NameNode，出现脑裂现象</p>
<ul>
<li><code>kill</code> 指令</li>
<li>用户自定义脚本程序</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop-Yarn</title>
    <url>/post/36f328db.html</url>
    <content><![CDATA[<ul>
<li>一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台。</li>
</ul>
<span id="more"></span>

<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="ResourceManager（RM）"><a href="#ResourceManager（RM）" class="headerlink" title="ResourceManager（RM）"></a>ResourceManager（RM）</h2><ul>
<li><p>独立的<strong>守护进程</strong>。</p>
</li>
<li><p>由 Scheduler 和 ApplicationsMaster（ASM） 组成。</p>
</li>
<li><p>处理 Client 请求。</p>
</li>
<li><p>监控 NodeManger。</p>
</li>
<li><p>启动&#x2F;监控 AppliacationMaster。</p>
</li>
<li><p>资源的分配与调度。</p>
</li>
</ul>
<h2 id="NodeManager（NM）"><a href="#NodeManager（NM）" class="headerlink" title="NodeManager（NM）"></a>NodeManager（NM）</h2><ul>
<li>每个节点对于一个 NodeManager，管理单个节点的资源。</li>
<li>处理来自 ResourceManager 的命令。</li>
<li>处理来自 ApplicationMaster 的命令。</li>
<li>监控节点状态、资源使用情况和 Container 运行情况，并定期回报给 ResourceManager。</li>
<li>类似 TaskTracker。</li>
</ul>
<h2 id="ApplicationMaster（AM）"><a href="#ApplicationMaster（AM）" class="headerlink" title="ApplicationMaster（AM）"></a>ApplicationMaster（AM）</h2><ul>
<li><p>每一个提交的 Job 都由一个与之对应的 ApplicationMaster 来管理。</p>
</li>
<li><p>负责数据的切片。</p>
</li>
<li><p>为应用程序申请资源并分配给内部任务。</p>
</li>
<li><p>任务的监控与容错。</p>
</li>
</ul>
<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><ul>
<li>是资源的抽象。</li>
<li>封装了某个节点上的多维度资源，例如内存、CPU、磁盘、网络等。</li>
</ul>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/image-20230318143430711.png" alt="image-20230318143430711"></p>
<ol>
<li>Client 向 RM 提交 Job，RM 会返回一个 ApplicationID 作为回应。</li>
<li>RM 根据从 Client 的 NM 收集的资源信息，调度一个合适的 NM，来启动一个 Container（常被称为 container0）以运行 AM 实例。</li>
<li>AM 创建成功后向 RM 中的 ASM 注册自己。</li>
<li>AM 注册成功后，会对数据进行切分，然后向 RM 申请资源，以 Container 的形式，RM 会根据调度策略提供资源。</li>
<li>AM 申请到资源成功后，会与 NM 通信，请求启动任务。</li>
<li>NM 接收到 AM 的请求后，根据 Job 提供的信息，启动对应的 Task。</li>
<li>启动后的每个 Task 会定时向 AM 提供自己的状态信息和执行的进度。</li>
<li>运行完成后 AM 会向 ASM 注销和关闭自己，AM 会释放相应的 Container。</li>
</ol>
<h1 id="资源调度器"><a href="#资源调度器" class="headerlink" title="资源调度器"></a>资源调度器</h1><h2 id="FIFO-Schedule-（先进先出调度器）"><a href="#FIFO-Schedule-（先进先出调度器）" class="headerlink" title="FIFO Schedule （先进先出调度器）"></a>FIFO Schedule （先进先出调度器）</h2><h2 id="Capacity-Scheduler（容量调度器）"><a href="#Capacity-Scheduler（容量调度器）" class="headerlink" title="Capacity Scheduler（容量调度器）"></a>Capacity Scheduler（容量调度器）</h2><ul>
<li>支持<strong>多队列</strong>，每个队列可配置一定的资源量，每个队列采用FIFO调度策略。</li>
<li>为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定。<ol>
<li>计算每个队列中正在运行的任务数与其应该分得的计算资源之间的比值，选择一个该比值最小的队列——最闲的。</li>
<li>按照作业优先级和提交时间顺序，同时考虑用户资源量限制和内存限制对队列内任务排序。</li>
</ol>
</li>
</ul>
<h2 id="Fair-Scheduler（公平调度器）"><a href="#Fair-Scheduler（公平调度器）" class="headerlink" title="Fair Scheduler（公平调度器）"></a>Fair Scheduler（公平调度器）</h2><ul>
<li>支持<strong>多队列多用户</strong>，每个队列中的资源量可以配置，同一队列中的作业<strong>公平共享</strong>队列中所有资源。</li>
<li>在资源有限的情况下，每个 Job 理想情况下获得的计算资源与实际获得的计算资源存在一种差距，这个差距就叫做<strong>缺额</strong>。在同一个队列中，Job 的资源<strong>缺额越大</strong>，越先获得资源优先执行，作业是按照缺额的高低来先后执行的。</li>
</ul>
<h1 id="任务的推测执行"><a href="#任务的推测执行" class="headerlink" title="任务的推测执行"></a>任务的推测执行</h1><ul>
<li>作业完成时间取决于最慢的任务完成时间。</li>
</ul>
<h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2><ul>
<li>发现较慢的任务，比如运行速度远慢于任务平均速度。为其启动一个<strong>备份任务</strong>，同时运行。采用先运行完的结果。</li>
</ul>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>每个 Task 只能有一个备份任务。</li>
<li>当前 Job 已完成的 Task 比例必须不小于 0.05</li>
</ul>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul>
<li><code>mapreduce.map.speculative</code> &#x3D; true</li>
</ul>
<h2 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h2><ul>
<li>Task 间存在严重的负载倾斜</li>
<li>特殊 Task，比如向数据库中写数据。</li>
</ul>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ul>
<li><p>假设某一时刻，Task 执行进度为 <code>progress</code>,则可通过一定的算法推测出该任务的最终完成时刻<code>estimateEndTime</code>。另一方面，如果此刻为该 Task 启动一个备份 Task，则可推断出它可能的完成时刻 estimateEndTime&#96;。</p>
</li>
<li><p>总是选择为 estimateEndTime-estimateEndTime’ 差值最大的 Task 启动备份Task。</p>
</li>
<li><p>为了防止大量 Task 同时启动备份 Task 造成的资源浪费，每个作业设置了同时启动的备份任务数目上限。</p>
</li>
<li><p>推测执行机制实际上采用了经典的优化算法：<strong>空间换时间</strong>，它同时启动多个相同任务处理相同的数据，并让这些任务<strong>竞争</strong>以缩短数据处理时间，这种方法需要占用更多的计算资源。在集群资源紧缺的情况下，应合理使用该机制，争取在多用少量资源的情况下，减少作业的计算时间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop-MapReduce</title>
    <url>/post/b2b0389b.html</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul>
<li><p>一个分布式运算程序的编程框架，是用户开发“基于Hadoop的数据分析应用”的核心框架。 </p>
</li>
<li><p>核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个Hadoop集群上。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>易于编程：简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量廉价的PC机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一样的。</li>
<li>良好的扩展性：当你的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。</li>
<li>高容错性：设计的初衷就是使程序能够部署在廉价的 PC 机器上，这就要求它具有很高的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，这个过程不需要人工参与。</li>
<li>适合PB级以上海量数据的离线处理可：以实现上千台服务器集群并发工作，提供数据处理能力。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>不擅长实时计算：无法在毫秒或者秒级内返回结果。</li>
<li>不擅长流式计算：输入数据集是静态的，不能动态变化，这是由自身的设计特点决定的。</li>
<li>多任务耗时：由于每执行一次任务后，结果都会存储磁盘中，多次操作会增大 IO 开销，这是由自身的设计特点决定的。</li>
<li>不擅长 DAG (有向图) 计算：没有相应的流程优化。</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="MrAppMaster"><a href="#MrAppMaster" class="headerlink" title="MrAppMaster"></a>MrAppMaster</h2><ul>
<li>负责整个程序的<strong>过程调度</strong>及<strong>状态协调</strong>。</li>
</ul>
<h2 id="MapTask"><a href="#MapTask" class="headerlink" title="MapTask"></a>MapTask</h2><ul>
<li>负责 Map 阶段的整个数据处理流程。</li>
</ul>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol>
<li>Read 阶段：通过用户编写的 RecordReader，从 InputSplit 中解析键值对。</li>
<li>Map 阶段：将解析出的 key&#x2F;value 交给用户编写 map() 函数处理，并产生一系列新的 key&#x2F;value。</li>
<li>Collect 阶段：在用户编写 map()函数中，当数据处理完成后，一般会调用 <code>OutputCollector.collect()</code> 输出结果。在该函数内部，它会将生成的 key&#x2F;value 分区（调用 Partitioner），并写入一个环形内存缓冲区中。</li>
<li>Spill 阶段：即“溢写”，当环形缓冲区满后，MapReduce 会将数据写到本地磁盘上， 生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。<ol>
<li>利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号进行排序，然后按照 key 进行排序。</li>
<li>按照分区编号由小到大依次写入任务工作目录下的临时文件 <code>output/spillN.out</code>（N 表示当前溢写次数）中。如果用户设置了 Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。 </li>
<li>将分区数据的元信息写到内存索引数据结构 <code>SpillRecord</code> 中，包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过 1MB，则将内存索引写到文件 <code>output/spillN.out.index</code> 中。</li>
</ol>
</li>
<li>Combine 阶段：当所有数据处理完成后，将所有临时文件合并成一个大文件，保存到文件 <code>output/file.out</code> 中，同时生成相应的索引文件 <code>output/file.out.index</code>。 文件合并以分区为单位。对于某个分区，它将采用<strong>多轮递归合并</strong>的方式。每轮合并 <code>io.sort.factor</code>（默认 10）个文件，并将产生的文件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件。 让每个 MapTask 最终只生成一个数据文件，可避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销。</li>
</ol>
<h3 id="并行度"><a href="#并行度" class="headerlink" title="并行度"></a>并行度</h3><ul>
<li>由切片数量决定</li>
</ul>
<h2 id="ReduceTask"><a href="#ReduceTask" class="headerlink" title="ReduceTask"></a>ReduceTask</h2><ul>
<li>负责 Reduce 阶段的整个数据处理流程。</li>
</ul>
<h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><ol>
<li>Copy 阶段：从各个 MapTask 上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</li>
<li>Merge 阶段：在远程拷贝数据的同时，ReduceTask 启动了<strong>两个后台线程</strong>对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。</li>
<li>Sort 阶段：按 key 进行聚合。由于各个 MapTask 已经实现对自己的处理结果进行了局部排序，因此只需对所有数据进行<strong>一次归并排序即</strong>可。</li>
<li>Reduce 阶段：reduce() 函数将计算结果写到 HDFS 上。</li>
</ol>
<h3 id="并行度-1"><a href="#并行度-1" class="headerlink" title="并行度"></a>并行度</h3><ul>
<li>默认为 1，可手动设置</li>
<li>要考虑业务逻辑需求，有些情况下，需要计算全局汇总结果，就只能有 1 个ReduceTask</li>
<li>如果分区数不是 1，但是 并行度为 1，则不会执行分区过程，因为在 MapTask 中，执行分区的前提是先判断 ReduceNum 个数是否大于 1。不大于 1 则不执行。</li>
</ul>
<h2 id="JobClient"><a href="#JobClient" class="headerlink" title="JobClient"></a>JobClient</h2><ul>
<li>作业与集群交互的主要接口，提供了提交作业、跟踪其进度、访问组件任务的报告&#x2F;日志的功能，获取集群状态信息等工具。</li>
</ul>
<h2 id="ObTracker"><a href="#ObTracker" class="headerlink" title="ObTracker"></a>ObTracker</h2><ul>
<li>对应 NameNode，后台服务进程，负责监听并接收各个 TaskTracker 发送的心跳信息，包括资源使用情况和任务运行情况等信息；同时有容错和为任务调度提供决策依据的功能，其中作业控制模块，负责作业的分解和状态监控包括 TaskTracker 状态监控、作业状态监控和任务状态监控。</li>
</ul>
<h2 id="TaskTracker"><a href="#TaskTracker" class="headerlink" title="TaskTracker"></a>TaskTracker</h2><ul>
<li>对应 DataNode，JobTracker 和 Task 之间的桥梁：一方面，从 JobTracker 接收并执行各种命令：运行任务、提交任务、杀死任务等；另一方面，将本地节点上各个任务的状态通过心跳周期性汇报给 JobTracker。</li>
</ul>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ul>
<li>运算程序往往需要分成至少 2 个阶段。</li>
<li>第一个阶段的 MapTask 并发实例，完全并行运行，互不相干。</li>
<li>第二个阶段的 ReduceTask 并发实例互不相干，但是他们的数据依赖于上一个阶段的所有 MapTask 并发实例的输出。</li>
<li>编程模型只能包含一个 Map 阶段和一个 Reduce 阶段，如果用户的业务逻辑非常复杂，那就只能多个 MapReduce 程序，<strong>串行运行</strong>。</li>
</ul>
<p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/70-20210323213006589.png" alt="MR"></p>
<ol>
<li>JobClient 向 JobTracker 申请可用Job ID。</li>
<li>JobClient 将运行 Job 所需要的资源拷贝到 HDFS 中，包括 MapReduce 程序打包的JAR文件、配置文件和客户端计算所得的输入切片信息，这些文件都存放在 JobTracker 专门为该作业创建的文件夹中，文件夹名为该作业的 Job ID。JAR文件默认会有10个副本（mapred.submit.replication）。</li>
<li>JobClient 向 JobTracker 提交 Job，JobTracker 接收到作业后，将其放在一个作业队列里，等待作业调度器对其进行调度。</li>
<li>当调度到该作业时，会根据输入切片信息为每个切片创建一个 MapTask，并将其分配给 TaskTracker 执行。</li>
<li>TaskTracker 会根据主机核的数量和内存的大小有分配固定数量的 map 槽和 reduce 槽：map 的任务分配遵循<strong>数据本地化（Data-Local）</strong>原则，将 map 任务分配给含有该 map 处理的数据块的 TaskTracker 上，同时将资源复制到该 TaskTracker 上来运行，这叫“<strong>运算移动，数据不移动</strong>”；分配 reduce 任务时则不考虑数据本地化。</li>
<li>JobTracker 初始化 Job。</li>
<li>JobTracker 从 HDFS 中获取输入切片。</li>
<li>与此同时，TaskTracker不断地向JobTracker汇报心跳信息，心跳中还携带着很多的信息，比如当前 map 任务完成的进度等。当 JobTracker 收到作业的最后一个任务完成信息时，便把该作业设置成“成功”。当 JobClient 查询状态时，如果它得知任务已完成，便显示一条消息给用户。</li>
<li>TaskTracker 得到 JobTracker 分配的任务后，从 HDFS 获取 Job 资源，若数据是本地的，不需拷贝数据。</li>
<li>TaskTracker 启动</li>
<li>JVM 子进程运运行</li>
</ol>
<h2 id="Input-Split-输入切片"><a href="#Input-Split-输入切片" class="headerlink" title="Input Split (输入切片)"></a>Input Split (输入切片)</h2><ul>
<li>数据切片只是在逻辑上对输入进行分片，并不会在磁盘上将其切分成片进行存储。</li>
<li>默认情况下，切片大小等于数据块大小。</li>
<li>输入分片（input split）只记录切片切片的<strong>元数据信息</strong>，例如起始位置、长度、所在节点列表等，并非数据本身。</li>
<li>切片时不考虑整体，而是逐个针对每个文件单独切片。</li>
<li>每个分片分配一个 MapTask 处理。</li>
</ul>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><code>mapreduce.input.fileinputformat.split.minsize</code> &#x3D; 1</li>
<li><code>mapreduce.input.fileinputformat.split.maxsize</code> &#x3D; <code>Long.MAXValue</code></li>
<li>切片大小 &#x3D; Math.max(minSize,Math.min(maxSize,blockSize));</li>
</ul>
<h2 id="Map-阶段"><a href="#Map-阶段" class="headerlink" title="Map 阶段"></a>Map 阶段</h2><p>就是程序员编写好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行；</p>
<h2 id="Combiner-阶段"><a href="#Combiner-阶段" class="headerlink" title="Combiner 阶段"></a>Combiner 阶段</h2><ul>
<li><p>Combiner 组件的父类是 Reducer，区别在于运行位置，Combiner 在每个MapTask 所在的节点运行。</p>
</li>
<li><p>目的在于对每个 MapTask 的输出进行<strong>局部合并</strong>，以<strong>减少网络传输量</strong>。</p>
</li>
<li><p>使用原则是不会影响到最终的业务输入，Combiner 的输出键值对应与 Reducer 的输出键值对对应。例如：只是求总数，最大值，最小值时可以使用 combiner，但做平均值计算时，最终的计算结果就会出错。</p>
</li>
</ul>
<h2 id="Shuffle-阶段"><a href="#Shuffle-阶段" class="headerlink" title="Shuffle 阶段"></a>Shuffle 阶段</h2><ul>
<li>shuffle 的本意是洗牌，把一组有一定规律的数据尽量打散转换成一组无规律的数据，而 MapReduce 中的 shuffle 更像是洗牌的逆过程，把一组无规律的数据尽量转换成一组<strong>具有一定规律的数据</strong>。</li>
</ul>
<img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/d7cab57d19fe44908d931805e87e4894.jpeg" alt="img" style="zoom:67%;" />

<ol>
<li>MapTask 收集输出的键值对，放到内存缓冲区中。</li>
<li>从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件。</li>
<li>多个溢出文件会被合并成大的溢出文件。</li>
<li>在溢出过程及合并的过程中，都要调用 <code>Partitioner</code> 的 <code>getPartition()</code> 方法进行分区和针对 key 进行排序 。</li>
<li>ReduceTask 根据自己的分区号，去各个 MapTask 机器上取相应的结果分区数据。</li>
<li>ReduceTask 会通过<strong>归并排序</strong>将这些数据再合并成大文件。</li>
</ol>
<h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><ul>
<li>缓冲区大小会影响到 MapReduce 程序的执行效率，原则上说，缓冲区越大， 磁盘 io 的次数越少，执行速度就越快。</li>
<li><code>io.sort.mb</code> &#x3D; 1</li>
</ul>
<h2 id="Partitioner（分区）"><a href="#Partitioner（分区）" class="headerlink" title="Partitioner（分区）"></a>Partitioner（分区）</h2><ul>
<li>默认分区时根据 key 的 hashCode 对 ReduceTasks 的个数取模得到，用户无法控制存储分区位置。</li>
</ul>
<h2 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort (排序)"></a>Sort (排序)</h2><ul>
<li><p>MapTask 和 ReduceTask 均会对数据按照 key 进行排序。</p>
</li>
<li><p>该操作属于 Hadoop 的默认行为，任何数据均会被排序，而不管逻辑上是否需要。</p>
</li>
<li><p>默认排序是按照字典顺序排序，使用<strong>快速排序</strong>。</p>
</li>
<li><p>对于 MapTask，它会将处理的结果暂时放到<strong>环形缓冲区</strong>中，当环形缓冲区使用率达到一定阈值后，再对缓冲区中的数据进行一次快速排序，并将这些有序数据<strong>溢写</strong>到磁盘上。当数据处理完毕后，它会对磁盘上所有文件进行<strong>归并排序</strong>。</p>
</li>
<li><p>对于Reduce Task,它从每个 MapTask 上远程拷贝相应的数据文件，如果文件大小超过一定阈值（默认 80），则&#x3D;&#x3D;进行一次排序&#x3D;&#x3D;，并溢写磁盘，否侧存储在内存中。如果内存中文件大小或者数目超过一定阈值，则进行一次合并，并将数据溢写到磁盘上；如果磁盘上文件数目达到一定阈值，则进行一次<strong>归并排序</strong>以生成一个更大文件。当所有数据拷贝完毕后，ReduceTask 统一对内存和磁盘上的所有数据进行一次<strong>归并排序</strong>。</p>
</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>部分排序：根据输入记录的键对数据集排序，保证输出的每个文件内部有序。</li>
<li>全排序：最终输出结果只有一个文件，且文件内部有序。实现方式是只设置一个 ReduceTask。但该方法在处理大型文件时效率极低，因为一台机器处理所有文件，完全丧失了 MapReduce 所提供的并行架构。</li>
<li>辅助排序：GroupingComparator 分组，在 Reduce 端对 key 进行分组。当接收的 key 为 bean 对象时，比较其中的若干字段进行排序。</li>
<li>二次排序：在自定义排序过程中，如果 <code>compareTo</code> 中的判断条件为两个即为二次排序。</li>
</ul>
<h2 id="Spill（溢写）"><a href="#Spill（溢写）" class="headerlink" title="Spill（溢写）"></a>Spill（溢写）</h2><ul>
<li>当排序完成，便开始把数据刷到磁盘，刷磁盘的过程以分区为单位，一个分区写完，写下一个分区，分区内数据有序，最终实际上会多次溢写，然后生成多个文件。</li>
<li>或者如果缓冲区的内存达到了阀值的80%时候，这个守护线程也会把内容写到磁盘上，另外的20%内存可以继续写入要写进磁盘的数据。</li>
</ul>
<h2 id="Merge-合并"><a href="#Merge-合并" class="headerlink" title="Merge(合并)"></a>Merge(合并)</h2><ul>
<li>spill 会生成多个小文件，对于 Reduce 端拉取数据是相当低效的，那么这时候就有了 merge 的过程，合并的过程也是同分片的合并成一个片段（segment），最终所有的 segment 组装成一个最终文件。</li>
</ul>
<h2 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h2><ul>
<li>和map函数一样也是程序员编写的，最终结果是存储在hdfs上的。</li>
</ul>
<h3 id="拉取拷贝（fetch-copy）"><a href="#拉取拷贝（fetch-copy）" class="headerlink" title="拉取拷贝（fetch copy）"></a>拉取拷贝（fetch copy）</h3><ul>
<li>Reduce 向各个 Map 任务拉取对应数据，这个过程都是以 Http 协议完成，每个 Map 节点都会启动一个常驻的 <strong>HTTP server</strong> 服务，通过其拉取数据。</li>
<li>这个过程完全通过<strong>网络传输</strong>，是一个非常重量级的操作。</li>
</ul>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><ul>
<li>计算机性能：CPU、内存、磁盘、网络</li>
<li>数据倾斜</li>
<li>Map、Reduce 个数设置不合理</li>
<li>前置 Task 运行过长，导致后续 Task 长时间等待</li>
<li>小文件过多</li>
<li>大量的不可分块的超大文件</li>
<li>Spill 次数过多</li>
<li>Merge 次数过多</li>
</ul>
<h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><p>框架默认的 <code>TextInputFormat</code> 切片机制对文件进行切片，不管文件多小，都会是一个单独的切片，都会交给一个 MapTask。如果有大量小文件，就会产生大量的 MapTask，导致处理效率极其低下。</p>
<ul>
<li>Hadoop Archive：高效地将小文件放入 HDFS 块中的文件存档工具，它能够将多个小文件打包成一个 HAR 文件，这样就减少了 NameNode 的内存使用。 </li>
<li>Sequence File：由一系列的二进制键值对组成，如果 key 为文件名，value 为文件内容，则可以将大批小文件合并成一个大文件。</li>
<li>CombineFilelnputFormat：用于将多个文件合并成一个单独的切片，会考虑数据的存储位置。</li>
<li>开启JVM重用：对于大量小文件 Job,可以减少 45% 运行时间。开启重用后，一个 Task 运行完毕后，JVM 会继续运行其他 Task。设置 <code>mapreduce.job.jvm.numtasks</code> 在 10-20 之间。</li>
</ul>
<h2 id="Map-阶段-1"><a href="#Map-阶段-1" class="headerlink" title="Map 阶段"></a>Map 阶段</h2><ul>
<li>减少谥写次数：通过调整<code>io.sort.mb</code>及<code>sort.spill.percent</code>，增大触发溢写的内存上限，减少溢写次数，从而减少磁盘 IO。</li>
<li>减少合并次数：通过调整&#96;&#96;io.sort.factor&#96;，增大触发合并的文件数目，减少合并的次数，从而缩短处理时间。</li>
<li>在Map之后，不影响业务逻辑前提下，先进行 Combines 处理，减少I&#x2F;O。</li>
</ul>
<h2 id="Reduce-阶段"><a href="#Reduce-阶段" class="headerlink" title="Reduce 阶段"></a>Reduce 阶段</h2><ul>
<li>合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致 Task 等待，延长处理时间；太多，会导致 Task 间竞争资源，造成处理超时等错误。</li>
<li>设置Map、Reduce:共存：调整<code>slowstart.completedmaps</code>，使 Map 运行到一定程度后，Reduce 也开始运行，减少 Reduce 的等待时间。</li>
<li>规避使用 Reduce：因为 Reduce 在用于<strong>连接数据集</strong>的时候将会产生大量的网络消耗。</li>
<li>合理设置 Reduce 端的 Buffer：默认情况下，数据达到一个阈值，Buffer 中的数据就会写入磁盘，然后 Reduce 再从磁盘中获得所有的数据。也就是说，Buffer 和 Reduce 是没有直接关联的。设置 <code>mapreduce.reduce.input.buffer.percent</code>（默认为 0.0），使得 Buffer 中的一部分数据可以直接输送到 Reduce,减少 IO 开销。当值大于 0 的候，会保留指定比例的内存读 Buffer 中的数据直接发送给 Reduce 使用。</li>
</ul>
<h2 id="I-x2F-O-传输"><a href="#I-x2F-O-传输" class="headerlink" title="I&#x2F;O 传输"></a>I&#x2F;O 传输</h2><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><ul>
<li><p>能够有效减少 HDFS 的读写字节数，提高网络带宽和磁盘空间的效率。在运行 MR时，I&#x2F;O操作、网络数据传输、Shuffle 和 Merge 要花大量的时间，尤其是数据规模很大和工作负载密集的情况下。</p>
</li>
<li><p>可以在任意 MapReduce 阶段启用。</p>
</li>
<li><p>但同时增加了 CPU 运算负担，运用不当也可能降低性能。</p>
</li>
<li><p>基本原则：运算密集型的 Job：少用压缩；I&#x2F;O 密集型的 Job：多用压缩。</p>
</li>
<li><p>使用 <code>SequenceFile</code> 二进制文件。</p>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li><code>Writable</code>：Java的序列化是一个重量级序列化框架（Serializable)，会附带很多额外的信息（各种校验信息，Header,继承体系等)，不便于在网络中高效传输。所以，Hadoop自己开发了一套序列化机制。</li>
</ul>
<h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><ol>
<li><p>实现 Writable 接口</p>
</li>
<li><p>必须有空参构造函数，因为在反序列化时，需要反射调用空参构造函数</p>
</li>
<li><p>重写序列号方法与反序列化方法，序列化的顺序和反序列化的顺序必须完全一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  out.writeLong(upFlow);</span><br><span class="line">  out.writeLong(downFlow);</span><br><span class="line">  out.writeLong(sumFlow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  upFlow = in.readLong();</span><br><span class="line">  downFlow = in.readLong();</span><br><span class="line">  sumFlow = in.readLong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h2><p>数据频率倾斜：某一区域的数据量要远远大于其他区域。</p>
<p>数据大小倾斜：部分数据的大小要远远大于平均值。</p>
<ul>
<li>抽样和范围分区：可以通过对原始数据进行抽样得到的结果集来<strong>预设分区边界值</strong>。</li>
<li>自定义分区：基于输出键进行自定义分区。</li>
<li>Combine 使用：Combine可以大量地减小数据倾斜。在可能的情况下，Combine的目的就是聚合并精简数据。</li>
<li>采用Map Join：尽量避免Reduce Join。</li>
</ul>
<h1 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h1><h2 id="JobTracker"><a href="#JobTracker" class="headerlink" title="JobTracker"></a>JobTracker</h2><p>无容错机制，挂掉之后需要人工介入，重启。</p>
<p>用户可通过配置一些参数，以便JobTracker重启后，让作业恢复运行，这样JobTracker重启前，会在histrory log中记录各个作业的运行状态，这样在JobTracker重启后，重新提交这些作业，并只对未完成的task进行重新调度。</p>
<h2 id="TaskTracker-1"><a href="#TaskTracker-1" class="headerlink" title="TaskTracker"></a>TaskTracker</h2><p>当超过参数超过的时间间隔时未向jobTracker汇报心跳，则认为它死亡，并将其从调度池中删除；</p>
<p>还可设置一些tasktracker host，表示这些节点不允许接入集群，也不会被分配task。</p>
<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>当一个作业在某个tasktracker上失败的task个数超过设定值，则该tasktracker被加到该job的黑名单中</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>每个map Task，每个reduce task都有最大尝试次数</p>
<h3 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><code>mapreduce.map.maxattempts</code> &#x3D; 4</li>
<li><code>mapreduce.reduce.maxattemp</code> &#x3D; 4</li>
<li><code>mapreduce.task.timeout</code> &#x3D; 600000 ms</li>
</ul>
<h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><p>可设置跳过坏记录的条数。</p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>用户可配置多个磁盘目录，将map task中间结果分到不同的磁盘上，增强容错性。map task临时结果将被轮询写到这些目录上，以避免某个磁盘文件目录数据过多。<br>也可每次选择数据最少的磁盘目录写入，采样小顶堆等。</p>
<h1 id="FileSystem-Cache"><a href="#FileSystem-Cache" class="headerlink" title="FileSystem.Cache"></a>FileSystem.Cache</h1><ul>
<li><p>某种程度上相当于搞了个全局变量。</p>
</li>
<li><p>如果不使用 cache，每个FileSystem的实例都会建立一个到 NamenNde 的连接，而在大数据计算的场景下，MapReduce&#x2F;Spark 要对 HDFS 进行大量并发的读，不做缓存会造成超量的连接打到 NameNode 上，造成DDOS的效果。</p>
</li>
<li><p>但有了 cache 就意味着同一个文件系统的实例被同时使用，如果使用用 try，或者用完之后主动 close，就会导致这个文件系统实例的其它使用方意外出错。</p>
</li>
<li><p>因此不要主动 close， FileSystem 有一个 shutdown 的 hook 会负责最后关掉这些 FileSystem，以防止泄漏。</p>
</li>
<li><p>又因为缓存的粒度是文件系统级别的，一般的应用文件系统的个数不应该太多，所以不会是个大问题。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive</title>
    <url>/post/7c5f14c6.html</url>
    <content><![CDATA[<p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2ODAzNzk1,size_26,color_FFFFFF,t_70.jpeg" alt="hive架构"></p>
<ol>
<li><p>数据存储位置</p>
<p>Hive的数据存储在<strong>hdfs上</strong>，<strong>元数据可以存储在指定的地方比如mysql，PostgreSQL</strong>等。</p>
</li>
<li><p>数据更新</p>
<p>Hive处理数据时一般不对数据进行改写，因为它不支持行级别的增删操作，<strong>如果要进行更新数据，一般可以通过分区或者表直接覆盖。</strong></p>
</li>
<li><p><strong>执行效率</strong></p>
<p>Hive 执行延迟较高。虽然在小数据量时传统数据库延迟更低，但<strong>是当数据规模大到超过传统数据库的处理能力的时候，Hive 的并行计算显然能体现出优势。</strong></p>
</li>
<li><p><strong>数据规模</strong></p>
<p>Hive <strong>支持大规模的数据计算，通常是PB级别</strong>的数据。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/post/5cd2e029.html</url>
    <content><![CDATA[<p>Spark 延续了MapReduce 的设计思路：对数据的计算也分为Map 和Reduce 两类。但不同的是，一个Spark 任务并不止包含一个Map 和一个Reduce，而是由一系列的Map、Reduce构成。这样，计算的中间结果可以高效地转给下一个计算步骤，提高算法性能。虽然Spark 的改进看似很小，但实验结果显示，它的算法性能相比MapReduce 提高了10～100 倍。</p>
<span id="more"></span>

<h1 id="与-MR-异同"><a href="#与-MR-异同" class="headerlink" title="与 MR 异同"></a>与 MR 异同</h1><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><ol>
<li><p>集流批处理、交互式查询、机器学习及图计算等于一体</p>
</li>
<li><p>基于<strong>内存迭代式</strong>计算，适合低延迟、迭代运算类型作业</p>
</li>
<li><p>可以通过缓存共享 rdd、DataFrame 提升效率【尤其是SparkSQL可以将数据以列式的形式存储于内存中】</p>
</li>
<li><p>中间结果支持 checkpoint ，遇错可快速恢复</p>
</li>
<li><p>支持 DAG,map 之间以 pipeline 方式运行，无需刷磁盘</p>
</li>
<li><p><strong>多线程</strong>模型，每个 worker 节点运行一个或多个 executor 服务，每个 task 作为线程运行在 executor 中，task 间可通过<strong>内存</strong>共享资源</p>
</li>
<li><p>Spark 编程模型更灵活，支持多种语言如 java、scala、python、R，并支持丰富的 transformation 和 action 的算子</p>
</li>
</ol>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><ol>
<li><p>适合离线数据处理，不适合迭代计算、交互式处理、流式处理</p>
</li>
<li><p>中间结果需要落地，需要大量的磁盘 IO 和网络 IO 影响性能</p>
</li>
<li><p>虽然 MapReduce 中间结果可以存储于 HDFS，利用 HDFS 缓存功能，但相对 Spark 缓存功能较低效</p>
</li>
<li><p><strong>多进程</strong>模型，任务调度（频繁申请、释放资源）和启动开销大，不适合低延迟类型作业</p>
</li>
<li><p>编程不够灵活，仅支持 map 和 reduce 两种操作。</p>
</li>
</ol>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Spark 集群的独立部署环境中，不需要依赖其他的资源调度框架，自身就实现了资源调度的功能。</p>
<h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>一个主要负责资源的调度和分配的进程，并进行集群的监控等职责，类似于 Yarn 环境中的 RM。</p>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>一个运行在集群中的一台服务器上的进程，由 Master 分配资源对数据进行并行的处理和计算，类似于 Yarn 环境中 NM。</p>
<h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>Spark 驱动器节点，用于执行 Spark 任务中的 main 方法，负责实际代码的执行工作。</p>
<ul>
<li>将用户程序转化为 Job</li>
<li>在 Executor 之间调度 Task</li>
<li>跟踪 Executor 的执行情况</li>
<li>通过 UI 展示查询运行情况</li>
</ul>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>集群中工作节点（Worker）中的一个 JVM 进程，负责在 Spark Job 中运行具体的 Task，Task 彼此之间相互独立。</p>
<p>Spark 应用启动时，Executor 节点被同时启动，并且始终伴随着整个 Spark 应用的生命周期而存在。</p>
<p>通过自身的块管理器（Block Manager）为 RDD 提供内存式存储，RDD 是直接缓存在 Executor 内的，因此任务可以在运行时充分利用缓存数据加速运算。</p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><code>--num-executors </code></li>
<li><code>--num-executors </code></li>
<li><code>--num-executors </code></li>
</ul>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol>
<li>Task 提交后，都会先启动 Driver 程序；</li>
<li>随后 Driver 向集群管理器注册应用程序；</li>
<li>之后集群管理器根据此任务的配置文件分配 Executor 并启动；</li>
<li>Driver 开始执行 main 函数，Spark 查询为懒执行，当执行到 Action 算子时开始反向推算，根据宽依赖进行 Stage 的划分，每一个 Stage 对应一个 TaskSet，TaskSet 中有多个 Task，查找可用资源 Executor 进行调度；</li>
<li>根据本地化原则，Task 会被分发到指定的 Executor 去执行，在任务执行的过程中，Executor 也会不断与 Driver 进行通信，报告任务运行情况。</li>
</ol>
<h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><p>RDD（Resilient Distributed Datasets），弹性分布式数据集。传统的 MapReduce 虽然具有自动容错、平衡负载和可拓展性的优点，但是其最大缺点是在迭代计算式的时候，要进行大量的磁盘 IO 操作，而 RDD 正是解决这一缺点的<strong>抽象方法</strong>。</p>
<p>RDD 内部的数据集合在逻辑上和物理上被划分成多个小<strong>子集合</strong>，这样的每一个子集合我们将其称为分区（Partitions），分区的个数会决定并行计算的粒度，即并行任务的个数。</p>
<p>RDD 只是数据集的抽象，分区内部并不会存储具体的数据。Partition 类内包含一个 index 成员，表示该分区在 RDD 内的索引，通过索引 + 分区号可以确定唯一数据块，再利用底层数据存储层提供的接口就能从存储介质（如：HDFS、Memory）中提取出分区对应的数据。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>弹性<ul>
<li>存储的弹性：内存与磁盘的自动切换；</li>
<li>容错的弹性：数据丢失可以自动恢复；</li>
<li>计算的弹性：计算出错重试机制；</li>
<li>分片的弹性：可根据需要重新分片。</li>
</ul>
</li>
<li>分布式：数据存储在大数据集群不同节点上</li>
<li>数据集：RDD 封装了计算逻辑，并不保存数据</li>
<li>数据抽象：RDD 是一个抽象类，需要子类具体实现</li>
<li>不可变：RDD 封装了计算逻辑，是不可以改变的，想要改变，只能产生新的 RDD，在 新的 RDD 里面封装计算逻辑</li>
<li>可分区、并行计算</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="闭包检查"><a href="#闭包检查" class="headerlink" title="闭包检查"></a>闭包检查</h3><p>从计算的角度, 算子以外的代码都是在 Driver 端执行, 算子里面的代码都是在 Executor 端执行。那么在 scala 的函数式编程中，就会导致算子内经常会用到算子外的数据，这样就形成了闭包的效果，如果使用的算子外的数据无法序列化，就意味着无法传值给 Executor 端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化。</p>
<h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><p>速度是 Serializable 的 10 倍。当 RDD 在 Shuffle 数据的时候，简单数据类型、数组和字符串类型已经有 Kryo 序列化。</p>
<p>注意：即使使用 Kryo 序列化，也要继承 Serializable 接口。</p>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><ul>
<li>两个相邻 RDD 之间的关系</li>
</ul>
<h3 id="血缘关系"><a href="#血缘关系" class="headerlink" title="血缘关系"></a>血缘关系</h3><p>RDD 只支持粗粒度转换，即在大量记录上执行的单个操作。</p>
<p>将创建 RDD 的一系列 Lineage （血统）记录下来，以便恢复丢失的分区。</p>
<p>Lineage 会记录 RDD 的元数据信息和转换行为，当该 RDD 的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。</p>
<h3 id="窄依赖"><a href="#窄依赖" class="headerlink" title="窄依赖"></a>窄依赖</h3><p>表示每一个父（上游） RDD 的 Partition 最多被子（下游）RDD 的一个 Partition 使用。</p>
<ul>
<li>独生子女</li>
</ul>
<h3 id="宽依赖"><a href="#宽依赖" class="headerlink" title="宽依赖"></a>宽依赖</h3><p>表示同一个父（上游）RDD 的 Partition 被多个子（下游）RDD 的 Partition 依赖，会引起 Shuffle。</p>
<ul>
<li>多生</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><ul>
<li>通过 cache 或 persist 方法将前面的计算结果缓存</li>
</ul>
<p>默认情况下会把数据以缓存的形式存储在 JVM 的堆内存中。缓存有可能丢失，或者由于内存不足而被删除，但 RDD 的<strong>缓存容错机制</strong>保证了即使缓存丢失也能保证计算的正确执行。</p>
<p>由于 RDD 的各个 Partition 是相对独立的，因此只需要计算丢失的部分即可， 并不需要重算全部 Partition。 </p>
<p>Spark 会自动对一些 Shuffle 操作的中间数据做持久化操作，比如：reduceByKey。这样做是为了当一个节点 Shuffle 失败时避免重新计算整个输入。但是，在实际使用的时候，如果想重用数据，仍然建议调用 persist 或 cache。</p>
<p>遵循懒加载原则，cache 操作并不会马上被执行，必须执行 Action 操作才能触发。</p>
<h3 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h3><ul>
<li>将 RDD 中间结果写入磁盘</li>
</ul>
<p>由于血缘依赖过长会造成容错成本过高，如果检查点之后有节点出现问题，可以从检查点开始重做血缘，减少了开销。</p>
<p>遵循懒加载原则，checkpoint 操作并不会马上被执行，必须执行 Action 操作才能触发。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>Cache 只是将数据保存起来，不切断血缘依赖；Checkpoint 切断血缘依赖。</li>
<li>Cache 缓存的数据通常存储在磁盘、内存等地方，可靠性低；Checkpoint 的数据通常存储在 HDFS 等容错、高可用的文件系统，可靠性高。</li>
</ul>
<p>建议对 checkpoint 的 RDD 使用 Cache 缓存，这样 checkpoint 的 job 只需从 Cache 缓存中读取数据，否则需要再从头计算一次。</p>
<h1 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h1><h2 id="mapPartition"><a href="#mapPartition" class="headerlink" title="mapPartition"></a>mapPartition</h2><p>对 rdd 中的整个分区的迭代器进行操作。</p>
<h3 id="与-map-的比较"><a href="#与-map-的比较" class="headerlink" title="与 map 的比较"></a>与 map 的比较</h3><ul>
<li><p>map 是对 rdd 中的每一个元素进行操作。</p>
</li>
<li><p>如果在这一过程中需要频繁创建额外的对象，则性能更高，例如将 rdd 中的数据通过 jdbc 写入数据库，map 需要为每个元素创建一个链接而 mapPartition 只需要为每个分区创建一个链接。</p>
</li>
<li><p>如果分区中数据量较大，容易导致内存不足。</p>
</li>
</ul>
<h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>将数据集中重复的数据去重。</p>
<h3 id="替代实现"><a href="#替代实现" class="headerlink" title="替代实现"></a>替代实现</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">map(x =&gt; (x, <span class="literal">null</span>)).reduceByKey((x, *) =&gt; x, numPartitions).map(*._1)</span><br></pre></td></tr></table></figure>

<h2 id="reduceByKey"><a href="#reduceByKey" class="headerlink" title="reduceByKey"></a>reduceByKey</h2><p>可以将 rdd 按照相同的 Key 对 Value 进行聚合。</p>
<h3 id="与-groupByKey-的比较"><a href="#与-groupByKey-的比较" class="headerlink" title="与 groupByKey 的比较"></a>与 groupByKey 的比较</h3><ul>
<li>从 shuffle 的角度：reduceByKey 和 groupByKey 都存在 shuffle 的操作，但是 reduceByKey 可以在 shuffle 前对分区内相同 key 的数据进行预聚合（combine）功能，这样会写入磁盘数据量；而 groupByKey 只是进行分组，不存在数据量减少的问题，reduceByKey 性能比较高。</li>
<li>从功能的角度：reduceByKey 其实包含分组和聚合的功能。GroupByKey 只能分组，不能聚合。</li>
</ul>
<h3 id="与其他聚合函数的比较"><a href="#与其他聚合函数的比较" class="headerlink" title="与其他聚合函数的比较"></a>与其他聚合函数的比较</h3><ul>
<li>reduceByKey: 相同 key 的第一个数据不进行任何计算，分区内和分区间计算规则相同。</li>
<li>foldByKey: 相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则相同。</li>
<li>aggregateByKey：相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则可以不相同。</li>
<li>combineByKey：当计算过程中发现数据结构不满足要求时，可以让第一个数据转换结构，分区内和分区间计算规则不相同。</li>
</ul>
<h1 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h1><ul>
<li>用来把 Executor 端变量信息聚合到 Driver 端。</li>
</ul>
<p>在 Driver 程序中定义变量，在 Executor 端的每个 Task 都会得到这个变量的一份新的副本。</p>
<p>每个 task 更新这些副本的值后， 传回 Driver 端进行 merge 操作。</p>
<h1 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h1><ul>
<li>用来高效分发较大的对象。</li>
</ul>
<p>向所有工作节点发送一个较大的只读变量，以供一个或多个 Spark 操作使用。</p>
<p>如果在多个并行操作中使用同一个变量，Spark 会为每个任务分别发送。</p>
<h1 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h1><p>总体来说分两路：Stage 级与 Task 级。</p>
<ul>
<li>Job 以 Action 方法为界，遇到一个 Action 方法则触发一个 Job；</li>
<li>Stage 是 Job 的子集，以 RDD 宽依赖（即 Shuffle）为界，遇到 Shuffle 做一次划分；</li>
<li>Task 是 Stage 的子集，以并行度（分区数）来衡量，分区数是多少，则有多少个 task。</li>
</ul>
<h2 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h2><h3 id="DAGScheduler"><a href="#DAGScheduler" class="headerlink" title="DAGScheduler"></a>DAGScheduler</h3><p>负责 Stage 级的调度，主要是将 job 切分成若干 Stages，并将每个 Stage 打包成 TaskSet 交给 TaskScheduler 调度。</p>
<h3 id="TaskScheduler"><a href="#TaskScheduler" class="headerlink" title="TaskScheduler"></a>TaskScheduler</h3><p>负责 Task 级的调度，将 DAGScheduler 给过来的 TaskSet 按照指定的调度策略分发到 Executor 上执行，调度过程中 SchedulerBackend 负责提供可用资源（SchedulerBackend 有多种实现，分别对接不同的资源管理系统）。</p>
<p>监控 Stage 的运行状态，只有 Executor 丢失或者 Task 由于 Fetch 失败才需要重新提交失败的 Stage 以调度运行失败的任务，其他类型的 Task 失败会在 TaskScheduler 的调度过程中重试。</p>
<h3 id="TaskSetManager"><a href="#TaskSetManager" class="headerlink" title="TaskSetManager"></a>TaskSetManager</h3><p>负责监控管理同一个 Stage 中的 Tasks，TaskScheduler 以 TaskSetManager 为单元来调度任务。</p>
<h3 id="SchedulerBackend"><a href="#SchedulerBackend" class="headerlink" title="SchedulerBackend"></a>SchedulerBackend</h3><p>通过 ApplicationMaster 申请资源</p>
<p>接收 Executor 的注册信息，并维护 Executor 的状态</p>
<p>不断从 TaskScheduler 中拿到合适的 Task 分发到 Executor 执行。</p>
<h3 id="HeartbeatReceiver"><a href="#HeartbeatReceiver" class="headerlink" title="HeartbeatReceiver"></a>HeartbeatReceiver</h3><p>负责接收 Executor 的心跳信息，监控 Executor 的存活状况，并通知到 TaskScheduler。</p>
<h2 id="Stage-级调度"><a href="#Stage-级调度" class="headerlink" title="Stage 级调度"></a>Stage 级调度</h2><p>从 DAG 切割开始，主要是由 DAGScheduler 来完成。当遇到一个 Action 操作后就会触发一个 Job 的计算，并交给 DAGScheduler 来提交。</p>
<p>DAGScheduler 会根据 DAG 进行切分，将一个 Job 划分为若干 Stages，具体划分策略是，由最终的 RDD 不断通过依赖回溯判断父依赖是否是宽依赖，即以 Shuffle 为界，划分 Stage，窄依赖的 RDD 会被划分到同一个 Stage 中。</p>
<p>划分的 Stages 分两类，一类叫做 ResultStage，为 DAG 最下游的 Stage，由 Action 方法决定；另一类叫做 ShuffleMapStage，为下游 Stage 准备数据。</p>
<p>一个 Stage 是否被提交，需要判断它的父 Stage 是否执行，只有其父 Stage 执行完毕才能提交当前 Stage。如果一个 Stage 没有父 Stage，那么从该 Stage 开始提交。</p>
<p>Stage 提交时会将 Task 信息（分区信息以及方法等）序列化并打包成 TaskSet 交给 TaskScheduler。</p>
<h2 id="Task-级调度"><a href="#Task-级调度" class="headerlink" title="Task 级调度"></a>Task 级调度</h2><p>DAGScheduler 将 Stage 打包到交给 TaskScheduler 后，TaskScheduler 会将 TaskSet 封装为 TaskSetManager 加入到调度队列中，TaskScheduler 以 TaskSetManager 为单元来调度任务，TaskScheduler 会从调度队列中按照指定的调度策略选择 TaskSetManager 去调度运行。</p>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><h3 id="FAIR"><a href="#FAIR" class="headerlink" title="FAIR"></a>FAIR</h3><p>有一个 rootPool 和多个子 Pool，各个子 Pool 中存储着所有待分配的 TaskSetMagager，需要先对子 Pool 进行排序，再对子 Pool 里面的 TaskSetMagager 进行排序，因为 Pool 和 TaskSetMagager 都继承了 Schedulable 特质，因此使用相同的排序算法。 </p>
<p>基于 Fair-share 比较，每个要排序的对象包含三个属性: <code>runningTasks</code>（正在运行的 Task 数）、<code>minShare</code>、<code>weight</code></p>
<h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><ul>
<li><code>fairscheduler.xml</code> 配置文件</li>
</ul>
<h4 id="比较过程"><a href="#比较过程" class="headerlink" title="比较过程"></a>比较过程</h4><ol>
<li>runningTasks 比 minShare 小的先执行</li>
<li>minShare 使用率低的先执行</li>
<li>权重使用率（runningTasks 与 weight 的比值）低的先执行</li>
<li>名字</li>
</ol>
<p>整体上来说就是通过 minShare 和 weight 这两个参数控制比较过程，可以做到让 minShare 使用率和权重使用率少（实际运行 task 比例较少）的先运行。 </p>
<p>排序完成后，所有的 TaskSetManager 被放入一个 ArrayBuffer 里，之后依次被取出并发送给 Executor 执行。</p>
<h3 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h3><p>Task 被提交到 Executor 启动执行后，Executor 会将执行状态上报给 SchedulerBackend，SchedulerBackend 则告诉 TaskScheduler，TaskScheduler 找到该 Task 对应的 TaskSetManager，并通知到该 TaskSetManager，这样 TaskSetManager 就知道 Task 的失败与成功状态。</p>
<p>对于失败的 Task，会记录它失败的次数，如果失败次数还没有超过最大重试次数，那么就把它放回待调度的 Task 池子中，否则整个 Application 失败。</p>
<h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><p>在记录 Task 失败次数过程中，会记录它上一次失败所在的 ExecutorId 和 Host，这样下次再调度这个 Task 时，会避免其被调度到上一次失败的节点上，起到一定的容错作用。黑名单记录还包含了其对应的“拉黑”时间，及这段时间内不再往这个节点上调度该 Task。</p>
<h1 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h1><p>数据倾斜就是我们在计算数据的时候，数据的分散度不够，导致大量的数据集中到了一台或者几台机器上计算，这些数据的计算速度远远低于平均计算速度，导致整个计算过程过慢。 </p>
<ul>
<li>key 分布不均匀</li>
<li>业务数据本身的特性</li>
<li>建表时考虑不周</li>
<li>某些 SQL 语句本身就有数据倾斜</li>
</ul>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p><strong>增加jvm</strong>（Java Virtual Machine：Java虚拟机）内存，这适用于变量值非常少的情况，这种情况下，往往只能通过硬件的手段来进行调优，增加jvm内存可以显著的提高运行效率；</p>
<p><strong>增加reduce的个数</strong>，这适用于变量值非常多的情况，这种情况下最容易造成的结果就是大量相同key被partition到一个分区，从而一个reduce执行了大量的工作；</p>
<p><strong>重新设计key</strong>，有一种方案是在map阶段时给key加上一个随机数，有了随机数的key就不会被大量的分配到同一节点(小几率)，待到reduce后再把随机数去掉即可；</p>
<p><strong>使用combiner合并</strong>。combinner是在map阶段，reduce之前的一个中间阶段，在这个阶段可以选择性的把大量的相同key数据先进行一个合并，可以看做是local reduce，然后再交给reduce来处理，减轻了map端向reduce端发送的数据量(减轻了网络带宽)，也减轻了map端和reduce端中间的shuffle阶段的数据拉取数量(本地化磁盘IO速率)；（hive.map.aggr&#x3D;true）</p>
<p><strong>设置合理的map reduce的task数</strong>，能有效提升性能。（比如，10w+级别的计算，用160个reduce，那是相当的浪费，1个足够）；</p>
<p>数据量较大的情况下，**慎用count(distinct)**，count(distinct)容易产生倾斜问题；</p>
<p><strong>hive.groupby.skewindata&#x3D;true</strong>，有数据倾斜的时候进行负载均衡，当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作。</p>
<h1 id="留存计算"><a href="#留存计算" class="headerlink" title="留存计算"></a>留存计算</h1><p>用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用该应用的用户，被认作是留存用户，这部分用户占当时新增用户的比例即是留存率，会按照每隔1单位时间（例日、周、月）来进行统计。</p>
<p>留存指的就是“有多少用户留下来了”。留存用户和留存率体现了应用的质量和保留用户的能力。</p>
<p>N日留存率&#x3D;某日新增且过N日还登录的用户数 &#x2F; 某日新增的用户数*100% </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">aa.dayno 日期,</span><br><span class="line">aa.活跃用户数,</span><br><span class="line">aa.次日留存用户数,</span><br><span class="line">aa.三日留存用户数,</span><br><span class="line">aa.七日留存用户数, </span><br><span class="line">concat(round(<span class="number">100</span> <span class="operator">*</span> 次日留存用户数<span class="operator">/</span>活跃用户数, <span class="number">2</span>), <span class="string">&#x27;%&#x27;</span>) 次日留存率,</span><br><span class="line">concat(round(<span class="number">100</span> <span class="operator">*</span> 三日留存用户数<span class="operator">/</span>活跃用户数, <span class="number">2</span>), <span class="string">&#x27;%&#x27;</span>) 三日留存率,</span><br><span class="line">concat(round(<span class="number">100</span> <span class="operator">*</span> 七日留存用户数<span class="operator">/</span>活跃用户数, <span class="number">2</span>), <span class="string">&#x27;%&#x27;</span>) 七日留存率</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span> a.dayno 日期,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> a.uid) <span class="keyword">as</span> 活跃用户数,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> b.uid) <span class="keyword">as</span> 次日留存用户数,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> c.uid) <span class="keyword">as</span> 三日留存用户数,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> d.uid) <span class="keyword">as</span> 七日留存用户数</span><br><span class="line">  <span class="keyword">from</span> act_user_info a</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> act_user_info b <span class="keyword">on</span> a.uid <span class="operator">=</span> b.uid <span class="keyword">and</span> b.dayno <span class="operator">=</span> date_add(a.dayno, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> act_user_info c <span class="keyword">on</span> a.uid <span class="operator">=</span> c.uid <span class="keyword">and</span> c.dayno <span class="operator">=</span> date_add(a.dayno, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> act_user_info d <span class="keyword">on</span> a.uid <span class="operator">=</span> d.uid <span class="keyword">and</span> d.dayno <span class="operator">=</span> date_add(a.dayno, <span class="number">7</span>)</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a.dayno</span><br><span class="line">) aa;</span><br></pre></td></tr></table></figure>

<h1 id="透视（Pviot）"><a href="#透视（Pviot）" class="headerlink" title="透视（Pviot）"></a>透视（Pviot）</h1><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.groupBy(<span class="string">&quot;year&quot;</span>)</span><br><span class="line">	.pivot(<span class="string">&quot;month&quot;</span>)</span><br><span class="line">  .sum(<span class="string">&quot;num&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">xxx</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">table_test</span><br><span class="line">PIVOT(</span><br><span class="line">	聚合函数(num) </span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">month</span> <span class="keyword">in</span> (<span class="operator">&lt;</span>month_list<span class="operator">&gt;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="逆透视"><a href="#逆透视" class="headerlink" title="逆透视"></a>逆透视</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unpivot_df =  df_pivot.selectExpr(<span class="string">&quot;`年月`&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;stack(4, &#x27;项目1&#x27;, `项目1`,&#x27;项目2&#x27;, `项目2`, &#x27;项目3&#x27;, `项目3`, &#x27;项目x&#x27;, `项目x`) as (`项目`,`收入`)&quot;</span>) \</span><br><span class="line">        .<span class="built_in">filter</span>(<span class="string">&quot;`收入` &gt; 0 &quot;</span>) \</span><br><span class="line">        .orderBy([<span class="string">&quot;`年月`&quot;</span>, <span class="string">&quot;`项目`&quot;</span>]) \</span><br><span class="line">unpivot_df.show()</span><br></pre></td></tr></table></figure>

<h1 id="一行拆分多行"><a href="#一行拆分多行" class="headerlink" title="一行拆分多行"></a>一行拆分多行</h1><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.withColumn(<span class="string">&quot;name&quot;</span>, explode(split($<span class="string">&quot;name&quot;</span>, <span class="string">&quot;[ ]&quot;</span>)))</span><br></pre></td></tr></table></figure>

<h1 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h1><ul>
<li><p>reduceByKey，合并具有相同键的值</p>
</li>
<li><p>groupByKey，对具有相同键的值进行分组</p>
</li>
<li><p>combineByKey，使用不同的返回类型合并具有相同键的值</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">combineByKey(</span><br><span class="line">	createCombiner,</span><br><span class="line">	mergeValue,</span><br><span class="line">	mergeCombiners,</span><br><span class="line">	partitioner</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> res2 = res.combineByKey(</span><br><span class="line">  (v) =&gt; (v, <span class="number">1</span>),</span><br><span class="line">  (acc: (<span class="type">Int</span>, <span class="type">Int</span>), v) =&gt; (acc._1 + v, acc._2 + <span class="number">1</span>),</span><br><span class="line">  (acc1: (<span class="type">Int</span>, <span class="type">Int</span>), acc2: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; (acc1._1 + acc2._1, acc1._2 + acc2._2)</span><br><span class="line">).map&#123; <span class="keyword">case</span> (key, (sum, count)) =&gt; (key, sum / count.toFloat)&#125;</span><br><span class="line">res2.collectAsMap().foreach(println)</span><br></pre></td></tr></table></figure>

<ul>
<li>aggregation，与reduce()相似，但输入值和返回值的类型可以不一致</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">aggregate(zeroValue)</span><br><span class="line">(seqOp, combOp)</span><br><span class="line"><span class="keyword">val</span> res = input.aggregate((<span class="number">0</span>, <span class="number">0</span>))(</span><br><span class="line">	(acc, value) =&gt; (acc._1 + value, acc._2 + value),</span><br><span class="line">	(acc1, acc2) =&gt; (acc1._1 + acc2._1, acc1._2 + acc2._2))</span><br><span class="line"><span class="keyword">val</span> avg = res._1 / res._2.toDouble</span><br></pre></td></tr></table></figure>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li>sortByKey</li>
<li>sortBy</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBy</span></span>[<span class="type">K</span>](</span><br><span class="line">    f: (<span class="type">T</span>) =&gt; <span class="type">K</span>,</span><br><span class="line">    ascending: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">    numPartitions: <span class="type">Int</span> = <span class="keyword">this</span>.partitions.size)</span><br><span class="line">    (<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">K</span>], ctag: <span class="type">ClassTag</span>[<span class="type">K</span>]): <span class="type">RDD</span>[<span class="type">T</span>] =</span><br><span class="line">  <span class="keyword">this</span>.keyBy[<span class="type">K</span>](f)</span><br><span class="line">      .sortByKey(ascending, numPartitions)</span><br><span class="line">      .values</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keyBy</span></span>[<span class="type">K</span>](f: <span class="type">T</span> =&gt; <span class="type">K</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">T</span>)] = withScope &#123;  </span><br><span class="line">  <span class="keyword">val</span> cleanedF = sc.clean(f)  </span><br><span class="line">  map(x =&gt; (cleanedF(x), x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input.sortBy(x =&gt; x)</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义类<ol>
<li>继承Ordered类，重写compare方法</li>
<li>序列化</li>
<li>重写toString(可选，主要为了可以展示数据)</li>
</ol>
</li>
<li>implicit</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implicit val sortIntegersByString = new Ordering[Int] &#123;</span><br><span class="line">	override def compare(a: Int, b: Int) = a.toString.compare(b.String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>ROW ，以行的方式进行偏移，然后确定边界范围。</p>
<p>RANGE ，以逻辑的方式进行偏移，然后再确定边界范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;</span><br><span class="line">                order by &lt;用于排序的列名&gt;[ASC/DESC]</span><br><span class="line">                [frame_type] BETWEEN [start] AND [end])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>排名函数(ranking function) 包括rank，dense_rank， row_number，percent_rank， ntile等，后面我们结合例子来看。</li>
<li>分析函数 (analytic functions) 包括cume_dist，lag等。</li>
<li>聚合函数(aggregate functions)，就是我们常用的max, min, sum, avg等。</li>
</ol>
<h1 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h1><p>UDF：User-Defined-Function，用户自定义函数，数据是一进一出，功能类似于大多数数学函数或者字符串处理函数；</p>
<p>UDAF：User-Defined Aggregation Function，用户自定义聚合函数，数据是多进一出，功能类似于 count&#x2F;max&#x2F;min；</p>
<p>UDTF：User-Defined Table-Generating Functions，用户自定义表生成函数，数据是一进多出，功能类似于lateral view explore()；</p>
<h3 id="匿名注册"><a href="#匿名注册" class="headerlink" title="匿名注册"></a>匿名注册</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">spark.udf.register(<span class="string">&quot;prefixName&quot;</span>, (name:<span class="type">String</span>)=&gt; &#123;</span><br><span class="line">  <span class="string">&quot;Name: &quot;</span> + name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">spark.sql(<span class="string">&quot;select age, prefixName(name) from user&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="实名注册"><a href="#实名注册" class="headerlink" title="实名注册"></a>实名注册</h3><p>定义时要在后面加“ _”(注意前面有个空格) 。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAdult</span></span>(age: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spark.udf.register(<span class="string">&quot;isAdult&quot;</span>, isAdult _)</span><br></pre></td></tr></table></figure>

<h3 id="临时UDF"><a href="#临时UDF" class="headerlink" title="临时UDF"></a>临时UDF</h3><p>在org.apache.spark.sql.execution.command.CreateFunctionCommand类的run方法中，会判断创建的Function是否是临时方法，若是，则会创建一个临时Function。</p>
<p>临时函数直接注册到functionRegistry(实现类是SimpleFunctionRegistry)，即内存中。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTempFunction</span></span>(</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    info: <span class="type">ExpressionInfo</span>,</span><br><span class="line">    funcDefinition: <span class="type">FunctionBuilder</span>,</span><br><span class="line">    ignoreIfExists: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (functionRegistry.lookupFunctionBuilder(name).isDefined &amp;&amp; !ignoreIfExists) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TempFunctionAlreadyExistsException</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  functionRegistry.registerFunction(name, info, funcDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化UDF"><a href="#持久化UDF" class="headerlink" title="持久化UDF"></a>持久化UDF</h3><p>在org.apache.spark.sql.execution.command.CreateFunctionCommand中，会调用SessionCatalog的createFunction，最终执行了HiveExternalCatalog的createFunction。</p>
<p>创建永久函数会在Hive元数据库中创建相应的函数。</p>
<p>在解析SQL中的UDF时，会调用SessionCatalog的lookupFunction0方法，在此方法中，首先会检查内存中是否存在，如果不存在则会加载此UDF，加载时会把RESOURCE_URI发到ClassLoader的路径中，如果把UDF注册到内存的functionRegistry中。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookupFunction</span></span>(</span><br><span class="line">    name: <span class="type">FunctionIdentifier</span>,</span><br><span class="line">    children: <span class="type">Seq</span>[<span class="type">Expression</span>]): <span class="type">Expression</span> = synchronized &#123;</span><br><span class="line">  <span class="comment">// Note: the implementation of this function is a little bit convoluted.</span></span><br><span class="line">  <span class="comment">// We probably shouldn&#x27;t use a single FunctionRegistry to register all three kinds of functions</span></span><br><span class="line">  <span class="comment">// (built-in, temp, and external).</span></span><br><span class="line">  <span class="keyword">if</span> (name.database.isEmpty &amp;&amp; functionRegistry.functionExists(name.funcName)) &#123;</span><br><span class="line">    <span class="comment">// This function has been already loaded into the function registry.</span></span><br><span class="line">    <span class="keyword">return</span> functionRegistry.lookupFunction(name.funcName, children)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the name itself is not qualified, add the current database to it.</span></span><br><span class="line">  <span class="keyword">val</span> database = name.database.orElse(<span class="type">Some</span>(currentDb)).map(formatDatabaseName)</span><br><span class="line">  <span class="keyword">val</span> qualifiedName = name.copy(database = database)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (functionRegistry.functionExists(qualifiedName.unquotedString)) &#123;</span><br><span class="line">    <span class="comment">// This function has been already loaded into the function registry.</span></span><br><span class="line">    <span class="comment">// Unlike the above block, we find this function by using the qualified name.</span></span><br><span class="line">    <span class="keyword">return</span> functionRegistry.lookupFunction(qualifiedName.unquotedString, children)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The function has not been loaded to the function registry, which means</span></span><br><span class="line">  <span class="comment">// that the function is a permanent function (if it actually has been registered</span></span><br><span class="line">  <span class="comment">// in the metastore). We need to first put the function in the FunctionRegistry.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> why not just check whether the function exists first?</span></span><br><span class="line">  <span class="keyword">val</span> catalogFunction = <span class="keyword">try</span> &#123;</span><br><span class="line">    externalCatalog.getFunction(currentDb, name.funcName)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">AnalysisException</span> =&gt; failFunctionLookup(name.funcName)</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">NoSuchPermanentFunctionException</span> =&gt; failFunctionLookup(name.funcName)</span><br><span class="line">  &#125;</span><br><span class="line">  loadFunctionResources(catalogFunction.resources)</span><br><span class="line">  <span class="comment">// Please note that qualifiedName is provided by the user. However,</span></span><br><span class="line">  <span class="comment">// catalogFunction.identifier.unquotedString is returned by the underlying</span></span><br><span class="line">  <span class="comment">// catalog. So, it is possible that qualifiedName is not exactly the same as</span></span><br><span class="line">  <span class="comment">// catalogFunction.identifier.unquotedString (difference is on case-sensitivity).</span></span><br><span class="line">  <span class="comment">// At here, we preserve the input from the user.</span></span><br><span class="line">  <span class="keyword">val</span> info = <span class="keyword">new</span> <span class="type">ExpressionInfo</span>(catalogFunction.className, qualifiedName.unquotedString)</span><br><span class="line">  <span class="keyword">val</span> builder = makeFunctionBuilder(qualifiedName.unquotedString, catalogFunction.className)</span><br><span class="line">  createTempFunction(qualifiedName.unquotedString, info, builder, ignoreIfExists = <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// Now, we need to create the Expression.</span></span><br><span class="line">  functionRegistry.lookupFunction(qualifiedName.unquotedString, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>GIS-坐标投影</title>
    <url>/post/72b26748.html</url>
    <content><![CDATA[<h1 id="变换方法"><a href="#变换方法" class="headerlink" title="变换方法"></a>变换方法</h1><p>等积</p>
<p>相似</p>
<p>仿射</p>
<p>投影</p>
<p>控制点</p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>GIS</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub Pages</title>
    <url>/post/56fd4e32.html</url>
    <content><![CDATA[<blockquote>
<p>GitHub Pages是免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。</p>
</blockquote>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>搭建简单</li>
<li>完全免费</li>
<li>静态脚本</li>
<li>绑定域名</li>
<li>专注内容</li>
</ul>
<h2 id="仓库创建"><a href="#仓库创建" class="headerlink" title="仓库创建"></a>仓库创建</h2><ul>
<li>使用GitHub用户名，每个用户下只能建立一个</li>
<li>仓库命名要求：{username}.github.io</li>
<li>仓库用以存放网页的静态资源</li>
</ul>
<h2 id="仓库设置"><a href="#仓库设置" class="headerlink" title="仓库设置"></a>仓库设置</h2><ul>
<li>点击Settings</li>
<li>点击Pages</li>
<li>配置域名</li>
<li>配置分支</li>
<li>选择主题</li>
</ul>
<h2 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h2><ul>
<li>可自动解析域名</li>
<li>域名管理系统中设置域名 &#x2F;&#x2F; TODO</li>
<li>仓库根目录创建文件，命名为CNAME，内容为域名</li>
<li>开启HTTPS，勾选Enforce HTTPS</li>
</ul>
<h2 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h2><ul>
<li>官方框架，Jekyll，基于Ruby</li>
<li>第三方框架，Hexo，基于Node.js</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><p><a href="https://pages.github.com/">GitHub Pages</a></p>
</li>
<li><p><a href="https://jekyllrb.com/">Jekyll</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Course</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/post/b132932.html</url>
    <content><![CDATA[<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<span id="more"></span>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new &#123;layout&#125; &#123;title&#125; --path &#123;path&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新建文章</li>
<li><code>&#123;layout&#125;</code>，可选参数</li>
<li><code>--path &#123;path&#125;</code>，可选参数</li>
</ul>
<h2 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成静态文件</li>
</ul>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动本地服务器</li>
<li>默认网址：<a href="http://localhost:4000/">http://localhost:4000/</a></li>
</ul>
<h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo deploy</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo d</span></span><br></pre></td></tr></table></figure>

<ul>
<li>部署网站</li>
</ul>
<h2 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br></pre></td></tr></table></figure>

<ul>
<li>清除缓存文件 (<code>db.json</code>) </li>
<li>清除已生成的静态文件 (<code>public</code>)</li>
</ul>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm ls -dept 0</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前安装的插件</li>
</ul>
<p>── @waline&#x2F;<a href="mailto:&#104;&#x65;&#120;&#x6f;&#x2d;&#110;&#x65;&#x78;&#x74;&#x40;&#x32;&#x2e;&#x30;&#46;&#54;">&#104;&#x65;&#120;&#x6f;&#x2d;&#110;&#x65;&#x78;&#x74;&#x40;&#x32;&#x2e;&#x30;&#46;&#54;</a><br>├── <a href="mailto:&#104;&#101;&#x78;&#111;&#64;&#54;&#46;&#49;&#46;&#48;">&#104;&#101;&#x78;&#111;&#64;&#54;&#46;&#49;&#46;&#48;</a><br>├── <a href="mailto:&#x68;&#x65;&#x78;&#111;&#45;&#x61;&#98;&#x62;&#114;&#108;&#x69;&#x6e;&#x6b;&#64;&#x32;&#x2e;&#x32;&#x2e;&#x31;">&#x68;&#x65;&#x78;&#111;&#45;&#x61;&#98;&#x62;&#114;&#108;&#x69;&#x6e;&#x6b;&#64;&#x32;&#x2e;&#x32;&#x2e;&#x31;</a><br>├── <a href="mailto:&#x68;&#x65;&#x78;&#111;&#x2d;&#97;&#x64;&#109;&#x69;&#x6e;&#x40;&#50;&#46;&#51;&#x2e;&#48;">&#x68;&#x65;&#x78;&#111;&#x2d;&#97;&#x64;&#109;&#x69;&#x6e;&#x40;&#50;&#46;&#51;&#x2e;&#48;</a><br>├── <a href="mailto:&#104;&#x65;&#120;&#x6f;&#x2d;&#100;&#101;&#112;&#x6c;&#111;&#x79;&#101;&#114;&#45;&#x67;&#x69;&#116;&#64;&#x33;&#46;&#48;&#46;&#48;">&#104;&#x65;&#120;&#x6f;&#x2d;&#100;&#101;&#112;&#x6c;&#111;&#x79;&#101;&#114;&#45;&#x67;&#x69;&#116;&#64;&#x33;&#46;&#48;&#46;&#48;</a><br>├── <a href="mailto:&#104;&#101;&#x78;&#x6f;&#x2d;&#x64;&#x69;&#114;&#101;&#x63;&#116;&#111;&#114;&#121;&#45;&#99;&#97;&#x74;&#101;&#103;&#111;&#114;&#x79;&#x40;&#x31;&#x2e;&#x31;&#46;&#52;">&#104;&#101;&#x78;&#x6f;&#x2d;&#x64;&#x69;&#114;&#101;&#x63;&#116;&#111;&#114;&#121;&#45;&#99;&#97;&#x74;&#101;&#103;&#111;&#114;&#x79;&#x40;&#x31;&#x2e;&#x31;&#46;&#52;</a><br>├── <a href="mailto:&#x68;&#x65;&#x78;&#111;&#x2d;&#103;&#101;&#x6e;&#x65;&#114;&#97;&#x74;&#x6f;&#114;&#x2d;&#97;&#x72;&#99;&#x68;&#105;&#x76;&#101;&#x40;&#49;&#46;&#48;&#46;&#48;">&#x68;&#x65;&#x78;&#111;&#x2d;&#103;&#101;&#x6e;&#x65;&#114;&#97;&#x74;&#x6f;&#114;&#x2d;&#97;&#x72;&#99;&#x68;&#105;&#x76;&#101;&#x40;&#49;&#46;&#48;&#46;&#48;</a><br>├── <a href="mailto:&#104;&#x65;&#120;&#x6f;&#x2d;&#x67;&#101;&#110;&#101;&#x72;&#x61;&#x74;&#x6f;&#x72;&#45;&#99;&#97;&#x74;&#x65;&#103;&#x6f;&#114;&#121;&#64;&#x31;&#46;&#48;&#46;&#48;">&#104;&#x65;&#120;&#x6f;&#x2d;&#x67;&#101;&#110;&#101;&#x72;&#x61;&#x74;&#x6f;&#x72;&#45;&#99;&#97;&#x74;&#x65;&#103;&#x6f;&#114;&#121;&#64;&#x31;&#46;&#48;&#46;&#48;</a><br>├── <a href="mailto:&#104;&#101;&#120;&#x6f;&#x2d;&#103;&#101;&#x6e;&#x65;&#114;&#97;&#x74;&#111;&#x72;&#x2d;&#102;&#x65;&#x65;&#100;&#x40;&#x33;&#x2e;&#x30;&#46;&#48;">&#104;&#101;&#120;&#x6f;&#x2d;&#103;&#101;&#x6e;&#x65;&#114;&#97;&#x74;&#111;&#x72;&#x2d;&#102;&#x65;&#x65;&#100;&#x40;&#x33;&#x2e;&#x30;&#46;&#48;</a><br>├── <a href="mailto:&#104;&#x65;&#x78;&#111;&#x2d;&#103;&#101;&#x6e;&#x65;&#114;&#x61;&#x74;&#111;&#x72;&#x2d;&#x69;&#110;&#100;&#101;&#x78;&#64;&#x32;&#46;&#48;&#46;&#48;">&#104;&#x65;&#x78;&#111;&#x2d;&#103;&#101;&#x6e;&#x65;&#114;&#x61;&#x74;&#111;&#x72;&#x2d;&#x69;&#110;&#100;&#101;&#x78;&#64;&#x32;&#46;&#48;&#46;&#48;</a><br>├── <a href="mailto:&#104;&#101;&#x78;&#x6f;&#45;&#x67;&#x65;&#110;&#101;&#x72;&#97;&#116;&#111;&#x72;&#x2d;&#x73;&#x65;&#97;&#x72;&#99;&#x68;&#100;&#x62;&#x40;&#49;&#46;&#x34;&#x2e;&#x30;">&#104;&#101;&#x78;&#x6f;&#45;&#x67;&#x65;&#110;&#101;&#x72;&#97;&#116;&#111;&#x72;&#x2d;&#x73;&#x65;&#97;&#x72;&#99;&#x68;&#100;&#x62;&#x40;&#49;&#46;&#x34;&#x2e;&#x30;</a><br>├── <a href="mailto:&#104;&#101;&#120;&#x6f;&#x2d;&#x67;&#x65;&#110;&#101;&#114;&#97;&#x74;&#x6f;&#x72;&#45;&#x73;&#x69;&#x74;&#x65;&#109;&#x61;&#x70;&#64;&#51;&#46;&#48;&#x2e;&#x31;">&#104;&#101;&#120;&#x6f;&#x2d;&#x67;&#x65;&#110;&#101;&#114;&#97;&#x74;&#x6f;&#x72;&#45;&#x73;&#x69;&#x74;&#x65;&#109;&#x61;&#x70;&#64;&#51;&#46;&#48;&#x2e;&#x31;</a><br>├── <a href="mailto:&#104;&#101;&#120;&#x6f;&#x2d;&#x67;&#x65;&#x6e;&#x65;&#x72;&#x61;&#116;&#x6f;&#114;&#45;&#x74;&#97;&#x67;&#64;&#x31;&#46;&#x30;&#x2e;&#x30;">&#104;&#101;&#120;&#x6f;&#x2d;&#x67;&#x65;&#x6e;&#x65;&#x72;&#x61;&#116;&#x6f;&#114;&#45;&#x74;&#97;&#x67;&#64;&#x31;&#46;&#x30;&#x2e;&#x30;</a><br>├── <a href="mailto:&#104;&#x65;&#x78;&#x6f;&#45;&#x68;&#x65;&#108;&#112;&#x65;&#114;&#45;&#108;&#x69;&#118;&#101;&#x32;&#x64;&#64;&#x33;&#46;&#x31;&#46;&#49;">&#104;&#x65;&#x78;&#x6f;&#45;&#x68;&#x65;&#108;&#112;&#x65;&#114;&#45;&#108;&#x69;&#118;&#101;&#x32;&#x64;&#64;&#x33;&#46;&#x31;&#46;&#49;</a><br>├── <a href="mailto:&#104;&#101;&#120;&#111;&#x2d;&#x72;&#x65;&#110;&#x64;&#101;&#114;&#101;&#x72;&#45;&#101;&#106;&#x73;&#64;&#50;&#46;&#x30;&#46;&#x30;">&#104;&#101;&#120;&#111;&#x2d;&#x72;&#x65;&#110;&#x64;&#101;&#114;&#101;&#x72;&#45;&#101;&#106;&#x73;&#64;&#50;&#46;&#x30;&#46;&#x30;</a><br>├── <a href="mailto:&#x68;&#101;&#x78;&#x6f;&#x2d;&#x72;&#x65;&#110;&#x64;&#x65;&#114;&#101;&#114;&#x2d;&#x6d;&#x61;&#x72;&#107;&#101;&#100;&#x40;&#53;&#46;&#x30;&#46;&#x30;">&#x68;&#101;&#x78;&#x6f;&#x2d;&#x72;&#x65;&#110;&#x64;&#x65;&#114;&#101;&#114;&#x2d;&#x6d;&#x61;&#x72;&#107;&#101;&#100;&#x40;&#53;&#46;&#x30;&#46;&#x30;</a><br>├── <a href="mailto:&#104;&#101;&#120;&#111;&#45;&#x72;&#x65;&#110;&#x64;&#x65;&#x72;&#x65;&#x72;&#45;&#x73;&#x74;&#121;&#x6c;&#x75;&#x73;&#64;&#50;&#46;&#x30;&#x2e;&#x31;">&#104;&#101;&#120;&#111;&#45;&#x72;&#x65;&#110;&#x64;&#x65;&#x72;&#x65;&#x72;&#45;&#x73;&#x74;&#121;&#x6c;&#x75;&#x73;&#64;&#50;&#46;&#x30;&#x2e;&#x31;</a><br>├── <a href="mailto:&#104;&#101;&#x78;&#x6f;&#x2d;&#x73;&#x65;&#x72;&#118;&#x65;&#x72;&#64;&#51;&#46;&#48;&#x2e;&#x30;">&#104;&#101;&#x78;&#x6f;&#x2d;&#x73;&#x65;&#x72;&#118;&#x65;&#x72;&#64;&#51;&#46;&#48;&#x2e;&#x30;</a><br>├── <a href="mailto:&#104;&#x65;&#x78;&#x6f;&#x2d;&#116;&#x68;&#101;&#x6d;&#x65;&#45;&#108;&#x61;&#x6e;&#100;&#115;&#99;&#x61;&#x70;&#x65;&#64;&#x30;&#x2e;&#48;&#46;&#51;">&#104;&#x65;&#x78;&#x6f;&#x2d;&#116;&#x68;&#101;&#x6d;&#x65;&#45;&#108;&#x61;&#x6e;&#100;&#115;&#99;&#x61;&#x70;&#x65;&#64;&#x30;&#x2e;&#48;&#46;&#51;</a><br>├── <a href="mailto:&#104;&#x65;&#x78;&#x6f;&#x2d;&#119;&#x6f;&#114;&#x64;&#45;&#99;&#x6f;&#x75;&#x6e;&#x74;&#x65;&#x72;&#64;&#x30;&#x2e;&#48;&#x2e;&#51;">&#104;&#x65;&#x78;&#x6f;&#x2d;&#119;&#x6f;&#114;&#x64;&#45;&#99;&#x6f;&#x75;&#x6e;&#x74;&#x65;&#x72;&#64;&#x30;&#x2e;&#48;&#x2e;&#51;</a><br>├── <a href="mailto:&#x6c;&#105;&#118;&#101;&#50;&#x64;&#x2d;&#119;&#105;&#100;&#x67;&#101;&#x74;&#x2d;&#x6d;&#x6f;&#x64;&#101;&#108;&#x2d;&#x68;&#105;&#106;&#105;&#x6b;&#105;&#64;&#x31;&#46;&#48;&#x2e;&#x35;">&#x6c;&#105;&#118;&#101;&#50;&#x64;&#x2d;&#119;&#105;&#100;&#x67;&#101;&#x74;&#x2d;&#x6d;&#x6f;&#x64;&#101;&#108;&#x2d;&#x68;&#105;&#106;&#105;&#x6b;&#105;&#64;&#x31;&#46;&#48;&#x2e;&#x35;</a><br>└── <a href="mailto:&#108;&#x69;&#118;&#101;&#x32;&#100;&#45;&#x77;&#x69;&#x64;&#103;&#x65;&#116;&#45;&#x6d;&#111;&#100;&#x65;&#108;&#45;&#116;&#111;&#x72;&#111;&#x72;&#111;&#64;&#49;&#x2e;&#48;&#x2e;&#53;">&#108;&#x69;&#118;&#101;&#x32;&#100;&#45;&#x77;&#x69;&#x64;&#103;&#x65;&#116;&#45;&#x6d;&#111;&#100;&#x65;&#108;&#45;&#116;&#111;&#x72;&#111;&#x72;&#111;&#64;&#49;&#x2e;&#48;&#x2e;&#53;</a></p>
<h1 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h1><ul>
<li>NexT</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://hexo.io/zh-cn/docs/">Hexo</a></p>
<p><a href="http://theme-next.iissnan.com/">NexT</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Course</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>GIS-数据模型</title>
    <url>/post/7409e1a4.html</url>
    <content><![CDATA[<h1 id="矢量数据"><a href="#矢量数据" class="headerlink" title="矢量数据"></a>矢量数据</h1><h1 id="栅格数据"><a href="#栅格数据" class="headerlink" title="栅格数据"></a>栅格数据</h1><h2 id="像元"><a href="#像元" class="headerlink" title="像元"></a>像元</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="逐个像元编码"><a href="#逐个像元编码" class="headerlink" title="逐个像元编码"></a>逐个像元编码</h3><h3 id="游程编码"><a href="#游程编码" class="headerlink" title="游程编码"></a>游程编码</h3><h3 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h3><h1 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h1><h2 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h2><h2 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>在过去20年中，矢量数据模型是GIS中变化最大的方面，例如，ESRI公司所开发每种新软件包都对应一种新的矢量数据模型，Arc&#x2F;Info对应Coverage，ArcView对应Shapefile，<a href="https://so.csdn.net/so/search?q=ArcGIS&spm=1001.2101.3001.7020">ArcGIS</a>对应Geodatabase。Coverage和Shapefile是地理关系数据模型，它利用分离的系统来存储空间数据和属性数据，而Geodatabase是基于对象数据模型，它把空间数据和属性数据存储在唯一的系统中。</p>
<p>　　Coverage是拓扑的，Shapefile是非拓扑的。</p>
<p>　　Coverage支持三种基本拓扑关系：连接性、面定义、邻接性。</p>
<p>　　Shapefile多边形对于共享边界实际上有重复弧段且可彼此重叠，不同于Coverage所用的多个文件，它用几何学性质存储两个基本文件：以.shp为扩展名的文件存储要素几何学特征;以.shx为扩展名的文件保留要素几何特征的空间索引。</p>
<p>　　Shapefile:一种基于文件方式存储GIS数据的文件格式。至少由.shp,.dbf,.shx三个文件作成，分别存储空间，属性和前两者的关系。是GIS中比较通用的一种数据格式。</p>
<p>　　Coverage:一种拓扑数据结构，一般的GIS原理书中都有它的原理论述。数据结构复杂，属性缺省存储在Info表中。目前ArcGIS中仍然有一些分析操作只能基于这种数据格式进行操作。</p>
<p>　　Geodatabase:ArcInfo发展到ArcGIS时候推出的一种数据格式，一种基于RDBMS存储的数据格式，其有两大类：1.PersonalGeodatabse 用来存储小数据量数据，存储在Access的mdb格式中。2.ArcSDE Geodatabse存储大型数据，存储在大型数据库中Oracle,Sql Server,DB2等。可以实现并发操作，不过需要单独的用户许可。</p>
<p>　　<strong>Coverage数据模型</strong></p>
<p>　　Coverage是一个集合，它可以包含一个或多个要素类。在第一个商业化GIS软件Arc&#x2F;INFO之前，计算计划的图形表示源自通用的CAD软件，属性信息和几何要素放在一起，不利于空间信息的描述和分析。</p>
<p>　　Coverage的优势：</p>
<p>　　(1)空间数据与属性数据关联。空间数据存储于建立了索引的二进制文件中，属性数据存放在DBMS表中，二者以公共的标识编码关联。</p>
<p>　　(2)矢量数据间的拓扑关系得以保存。</p>
<p>　　<strong>Shapefile数据模型</strong></p>
<p>　　Shapefile是ArcView GIS3.x的原生数据格式，属于简单要素类，用点、线、多边形存储要素的形状，却不能存储拓扑关系，具有简单、快速显示的优点。一个shapefile是由若干个文件组成的，空间信息和属性信息分离存储，所以称之为“基于文件”。每个shapefile，都至少由三个文件组成，其中：*.shp存储的是几何要素的的空间信息，也就是XY坐标。*.shx存储的是有关*.shp存储的索引信息，它记录了在*.shp中，空间数据是如何存储的，XY坐标的输入点在哪里，有多少XY坐标对等信息。.dbf存储地理数据的属性信息的dBase表。这三个文件是一个shapefile的基本文件，shapefile还可以有其他一些文件，但所有这些文件都与该shapefile同名，并且存储在同一路径下。下面简要介绍一下其他一些较为常见文件：.prj如果shapefile定义了坐标系统，那么它的空间参考信息将会存储在*.prj文件中;<em>.shp.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a>这是对shapefile进行元数据浏览后生成的xml元数据文件;</em>.sbn和*.sbx这两个存储的是shapefile的空间索引，它能加速空间数据的读取，这两个文件是在对数据进行操作、浏览或连接后才产生的，也可以通过ArcToolbox&gt;DataManagementTools&gt;Indexes&gt;Add spatial Index工具生成。</p>
<p>　　几种常见的shapefile文件：当使用ArcCatalog对shapefile进行创建、移动、删除或重命名等操作，或使用ArcMap对shapefile进行编辑时，ArcCatalog将自动维护数据的完整性，将所有文件同步改变。所以需要使用ArcCatalog管理shapefile。虽然Shapefile无法存储拓扑关系，但它并不是普通用于显示的图形文件，作为地理数据，它自身有拓扑的。比如一个多边形要素类，shapefile会按顺时针方向为它的所有顶点排序，然后按顶点顺序两两连接成的边线向量，在向量右侧的为多边形的内部，在向量左侧的是多边形的外部。由于1990年代地理信息的迅速发展以及ArcViewGIS3.x软件在世界范围内的推广，shapefile格式的数据使用非常广泛，数据来源也较多。很多软件都提供了向shapefile转换的接口(eg：MapInfo、MapGIS等)。ArcGIS支持对shapefile的编辑操作，也支持shapefile向第三代数据模型geodatabase的转换。</p>
<p>　　<strong>Geodatabase数据模型</strong></p>
<p>　　Geodatabase作为ArcGIS的原生数据格式，体现了很多第三代地理数据模型的优势。随着IT技术的发展，普通的事务型数据的管理模式，早已从传统的基于文件的管理转向利用基于工业标准建立的关系型数据库进行管理，这种基于数据库的管理方式的优点是不言而喻的。那么带有空间信息的地理数据是否也可以利用这种非常成熟的数据库技术进行管理呢?于是ESRI推出了geodatabase数据模型，利用数据库技术高效安全地管理我们的地理数据。</p>
<p>　　Geodatabase可以分为两种，一种是基于Microsoft Access的personalgeodatabase，另一种是基于oracle、SQL Server、Informix或者DB2的enterprisegeodatabase，由于它需要中间件ArcSDE进行连接，所以nterprise geodatabase又称为ArcSDEgeodatabase。由于Microsoft Access自身容量的限制，personalgeodatabase的容量上限为2GB，这显然不能满足企业级的海量地理数据的存储需求。于是可以将geodatabase扩展为ArcSDEgeodatabase，底层数据库可以使用oracle这样的大型关系数据库，能够存储近乎“无限”的海量数据(仅受硬盘大小的限制)。虽然底层使用的数据库各不相同，但是geodatabase给用户提供的是一个一致的操作环境。在geodatabase中，不仅可以存储类似shapefile的简单要素类还可以存储类似coverage的要素集并且支持一系列的行为规则对其空间信息和属性信息进行验证表格、关联类、栅格、注记和尺寸都可以作为eodatabase对象存储。这些在perasonalgeodatabase和ArcSDE geodatabase中都是一样的(栅格的存储有点小差异，但对用户来说都是一样的)。</p>
<p>　　Geodatabase的模型结构：</p>
<p>　　(1)对象类(Object class)</p>
<p>　　对象类是一种特殊的类，没有空间特征。其实例是可关联某特定行为的表记录。如，某地块的主人，在“地块”“主人”间可建立某种关系。</p>
<p>　　(2)要素类(Feature class)</p>
<p>　　要素类是同类空间要素的集合。如，河流、道路、植被、电缆等。要素类可以独立存在，也可以具有某种联系。当不同的要素类之间存在关系时，就将其组织到一个要素数据集(Featuredataset)中。</p>
<p>　　(3)要素数据集(Feature dataset)</p>
<p>　　要素数据集由一组具有相同空间参考(Spatialreference)的要素类组成。将不同要素类放入要素数据集的原因：</p>
<p>　　a.专题归类表示——当不同的要素类属于同一范畴。比如，全国范围内某种比例尺的水系数据，其点线面类型的要素类可组织成同一个要素数据集。</p>
<p>　　b.创建几何网络——在同一几何网络中充当连接点和边的各种要素类，须组织到同一要素数据集中。比如，配电网络中，有各种开关、变压器、电缆等，它们分别对应点或线类型的要素类，在配电网络建模时，我们要将其全部考虑到配电网络对应的几何网络模型中。此时这些要素类就要放在统一要素数据集下。</p>
<p>　　c.考虑平面拓扑——共享公共几何特征的要素类。比如，用地、水系、行政区界等。当移动其中一个要素时，其公共部分也要一起移动，并保持这种公共的几何关系不变。</p>
<p>　　(4)关系类(Relationship class)</p>
<p>　　定义不同要素类或对象类之间的关联关系。如我们可以定义房子和主人之间的关系、房子和地块之间的关系等。</p>
<p>　　(5)几何网络</p>
<p>　　在若干要素类的基础上建立起的新类。定义几何网络时，我们指定哪些要素类加入其中，同时指定其在几何网络中扮演什么角色。比如，定义一个供水网络，我们指定同属一个要素数据集的“阀门”、“泵站”、“接头”对应的要素类加入其中，并扮演“连接”的角色;同时，我们要指定同属一个要素数据集的“供水干管”、“供水支管”、“入户管”等对应的要素类加入供水网络，由其扮演“边”的角色。</p>
<p>　　(6)Domains</p>
<p>　　定义属性的有效范围，可是连续的，也可是离散数值。</p>
<p>　　(7)Validationrules对要素类的行为和取值加以约束的规则。如不同管径的水管连接必须通过合适的接头，规定一个地块可拥有一到三个主人等。</p>
<p>　　(8)Raster datasets</p>
<p>　　用于存放栅格数据。支持海量栅格数据，支持影像镶嵌，可通过建立“金字塔”形索引，在使用时指定可视范围提高检索和显示效率。</p>
<p>　　(9)TIN Datasets</p>
<p>　　ARC&#x2F;INFO的经典数据模型，用不规则分布的采样点的采样值构成不规则的三角集合。用于表达地形或其他类型的空间连续分布特征。</p>
<p>　　(10)Locators</p>
<p>　　定位参考和定位方法的组合。对于不同的参考，用不同的定位方法进行定位操作。所谓定位参考，不同的定位信息有不同的表达方法。在Geodatabase中，有四种定位信息：地址编码、、地名及邮编、路径定位。定位参考数据放在数据库表中，定位器根据该定位参考数据在地图上生成空间定位点。</p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>GIS</category>
      </categories>
  </entry>
  <entry>
    <title>Java-JVM</title>
    <url>/post/424e4e36.html</url>
    <content><![CDATA[<ul>
<li>是可运行 Java 代码的假想计算机 ，包括字节码指令集、寄存器、栈、 垃圾回收堆和存储方法域。</li>
<li>运行在操作系统之上的，它与硬件没有直接的交互。</li>
</ul>
<span id="more"></span>

<h1 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h1><ul>
<li>分为线程私有区域（程序计数器、Java虚拟机栈、本地方法栈）、线程共享区域（堆、方法区）、直接内存。</li>
</ul>
<p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/337690-20200705145239881-919047261.png" alt="img"></p>
<h2 id="线程私有区域"><a href="#线程私有区域" class="headerlink" title="线程私有区域"></a>线程私有区域</h2><ul>
<li>随用户线程的启动&#x2F;结束而创建&#x2F;销毁。</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每个线程都有独立的程序计数器。</li>
<li>是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的内存区域。</li>
</ul>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li><p>用于描述方法执行，一个线程的方法的调用和返回对应栈的压栈和出栈。</p>
</li>
<li><p>主要存放一些基本的数据类型和对象句柄（引用）；存取速度比堆快，仅次于寄存器，栈数据可以共享；静态分配内存，编译时确定生存期大小。</p>
</li>
<li><p>每个方法在执行的同时都会创建一个栈帧(Stack Frame) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
</li>
<li><p>栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、 方法返回值和异常分派(Dispatch Exception)。栈帧随着方法调用而创建，随着方法结束而销毁。</p>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>与Java虚拟机栈作用类似，区别是前者为Native 方法服务，后者为 Java 方法服务。</li>
</ul>
<h2 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a>线程共享区域</h2><ul>
<li>随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁。</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li><p>保存创建的对象和数组，是垃圾收集器进行垃圾收集的最重要的内存区域。</p>
</li>
<li><p>从垃圾收集的角度细分为: 新生代(Eden 区、From Survivor 区、To Survivor 区)与老年代。</p>
</li>
</ul>
<h2 id="方法区-x2F-永久代"><a href="#方法区-x2F-永久代" class="headerlink" title="方法区&#x2F;永久代"></a>方法区&#x2F;永久代</h2><ul>
<li>永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. </li>
<li>HotSpot VM 把 GC 分代收集扩展至方法区, 即使用 Java 堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器。</li>
</ul>
<h2 id="直接内容"><a href="#直接内容" class="headerlink" title="直接内容"></a>直接内容</h2><ul>
<li>不是 JVM 运行时数据区的一部分, 但也会被频繁的使用。</li>
<li>在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作，这样就避免了在 Java 堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="运行内存"><a href="#运行内存" class="headerlink" title="运行内存"></a>运行内存</h2><h3 id="新生代-Young-Generation"><a href="#新生代-Young-Generation" class="headerlink" title="新生代(Young Generation)"></a>新生代(Young Generation)</h3><ul>
<li>用来存放新生的对象。一般占据堆的 1&#x2F;3 空间。</li>
<li>由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。</li>
</ul>
<h4 id="Eden"><a href="#Eden" class="headerlink" title="Eden"></a>Eden</h4><ul>
<li>Java 新对象的出生地。</li>
<li>如果新创建的对象占用内存很大，则直接分配到老年代。</li>
<li>当区内存不够的时候就会触发 MinorGC，对新生代进行一次垃圾回收。</li>
</ul>
<h4 id="From-Survivor"><a href="#From-Survivor" class="headerlink" title="From Survivor"></a>From Survivor</h4><ul>
<li>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</li>
</ul>
<h4 id="To-Survivor"><a href="#To-Survivor" class="headerlink" title="To Survivor"></a>To Survivor</h4><ul>
<li>保留了一次 MinorGC 过程中的幸存者。</li>
</ul>
<h3 id="老年代-Tenured-x2F-Old-Generation"><a href="#老年代-Tenured-x2F-Old-Generation" class="headerlink" title="老年代(Tenured&#x2F;Old Generation)"></a>老年代(Tenured&#x2F;Old Generation)</h3><ul>
<li>主要存放生命周期长的内存对象。</li>
<li>对象比较稳定，所以 MajorGC 不会频繁执行。</li>
</ul>
<h2 id="判断回收"><a href="#判断回收" class="headerlink" title="判断回收"></a>判断回收</h2><h3 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h3><ul>
<li>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。</li>
<li>缺点是不能解决循环引用的问题。</li>
</ul>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则称该对象是不可达达。</li>
<li>不可达对象不等价于可回收对象，不可达对象经历两次标记后仍然是可回收对象，则将面临回收。</li>
</ul>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><ul>
<li>最基础的垃圾回收算法，分为两个阶段，标记和清除。</li>
<li>标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。</li>
<li>缺点：内存碎片化严重。</li>
</ul>
<h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><ul>
<li><p>为了解决标记-清除算法算法内存碎片化的缺陷而被提出的算法。</p>
</li>
<li><p>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清理掉。</p>
</li>
<li><p>缺点：内存使用率不高，且存活对象过多，效率会大大降低。</p>
</li>
</ul>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><ul>
<li>结合了以上两个算法，为了避免缺陷而提出。</li>
<li>标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图:</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>目前大部分 JVM 所采用的方法，核心思想是根据对象存活的不同生命周期将内存划分为不同区域，根据不同区域选择不同算法。</li>
<li>一般情况下将堆划分为新生代和老生代，新生代一般采用复制算法，老年代一般采用标记-整理算法。</li>
</ul>
<h4 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h4><ul>
<li>每次只使用 Eden 和 From Survivor 区域存储，当内存不够时触发 MinorGC 进行垃圾回收。</li>
<li>Eden 和 From Survivor 区域中存活的对象复制到 To Survivor 区域，同时把这些对象的年龄+1。</li>
<li>如果有对象的年龄达到了老年的标准（默认为15岁），或者 To Servicor 区域位置不够，就复制到老年代。</li>
<li>清空 Eden 和 From Survivor 区域。</li>
<li>From Survivor 和 To Survivor 互换，原 To Survivor 成为下一次 GC 时的 From Survivor 区域。</li>
</ul>
<h4 id="老年代与标记-整理算法"><a href="#老年代与标记-整理算法" class="headerlink" title="老年代与标记-整理算法"></a>老年代与标记-整理算法</h4><ul>
<li>在进行 MajorGC 前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代。</li>
<li>当无法找到足够大的连续空间分配给新创建的较大对象时会抛出OOM(Out of Memory)异常，并提前触发一次  MajorGC 以腾出空间。</li>
</ul>
<h4 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h4><ul>
<li>将整个堆空间划分为连续的不同小区间, 每个小区间独立使用，独立回收。</li>
<li>可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间(而非整个堆)，从而减少一次 GC 所产生的停顿。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><ul>
<li><p>单线程、复制算法</p>
</li>
<li><p>最基本的垃圾收集器， JDK1.3.1 之前新生代唯一的垃圾收集器。</p>
</li>
<li><p>在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</p>
</li>
<li><p>简单高效，对于限定单 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率。</p>
</li>
<li><p>JVM 运行在 Client 模式下默认的新生代垃圾收集器。</p>
</li>
</ul>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><ul>
<li><p>多线程、复制算法</p>
</li>
<li><p>Serial 收集器的多线程版本，其余的行为和 Serial 收集器完全一样。</p>
</li>
<li><p>默认开启和 CPU 数目相同的线程数。</p>
</li>
<li><p>JVM 运行在 Server 模式下默认的新生代垃圾收集器。</p>
</li>
</ul>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><ul>
<li>多线程、复制算法、吞吐量</li>
<li>重点关注的是程序达到一个可控制的吞吐量（Thoughput）。</li>
<li>吞吐量：CPU 用于运行用户代码的时间&#x2F;CPU 总消耗时间，即运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)。</li>
<li>采用自适应调节策略。</li>
<li>主要适用于在后台运算而不需要太多交互的任务。</li>
</ul>
<h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><ul>
<li><p>单线程、标记-整理算法</p>
</li>
<li><p>Serial 的老年代版本。</p>
</li>
<li><p>JVM 运行在 Server 模式下默认的老年的代垃圾收集器。</p>
</li>
<li><p>在 Server 模式下，主要有两个用途:</p>
<ol>
<li>在 JDK1.5 之前版本中与 Parallel Scavenge 搭配使用。</li>
<li>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</li>
</ol>
</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><ul>
<li>多线程、标记-整理算法、吞吐量</li>
<li>Parallel Scavenge 的老年代版本。</li>
<li>JDK1.6开始提供。</li>
</ul>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul>
<li>多线程、标记-清除算法</li>
<li>年老代垃圾收集器，最主要目标是获取最短垃圾回收停顿时间，从而为交互比较高的程序提高用户体验。</li>
<li>初始标记：标记 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</li>
<li>并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</li>
<li>重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</li>
<li>并发清除：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。</li>
<li>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，因此总体上来看 CMS 和用户线程是一起并发地执行的。</li>
</ul>
<h3 id="G1（Garbage-first）收集器"><a href="#G1（Garbage-first）收集器" class="headerlink" title="G1（Garbage first）收集器"></a>G1（Garbage first）收集器</h3><ul>
<li>标记-整理算法、分区收集算法、吞吐量</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li>
<li>避免全区域垃圾收集，把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域 的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。</li>
</ul>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><ul>
<li>最常见的引用类型。</li>
<li>把一个对象赋给一个引用变量，这个引用变量就是一个强引用。</li>
<li>当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。</li>
<li>是造成 Java 内存泄漏的主要原因之 一。</li>
</ul>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><ul>
<li>用 SoftReference 类来实现。</li>
<li>对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。</li>
<li>软引用通常用在对内存敏感的程序中。</li>
</ul>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><ul>
<li>用 WeakReference 类来实现。</li>
<li>它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</li>
</ul>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><ul>
<li>用 PhantomReference 类来实现。</li>
<li>不能单独使用，必须和引用队列联合使用。</li>
<li>主要作用是跟踪对象被垃圾回收的状态。</li>
</ul>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9jdWl0,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p>
<ul>
<li>将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</li>
<li>最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</li>
</ul>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul>
<li><p>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。</p>
</li>
<li><p>一般的加载来源包括从本地路径下编译生成的、jar包中的、远程网络以及动态代理实时编译的.class文件。</p>
</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul>
<li><p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</p>
</li>
<li><p>包括对于文件格式的验证，比如常量中是否有不被支持的常量，文件中是否有不规范的或者附加的其他信息。</p>
</li>
<li><p>对于元数据的验证，比如该类是否继承了被final修饰的类，类中的字段、方法是否与父类冲突，是否出现了不合理的重载。</p>
</li>
<li><p>对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。</p>
</li>
<li><p>对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类，校验符号引用中的访问性（private，public等）是否可被当前类访问。</p>
</li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>主要是为类变量分配内存，并且赋予初值，即在方法区中分配这些变量所使 用的内存空间。</p>
</li>
<li><p>初值不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值：8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值。</p>
</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li>将常量池内的符号引用（类名、方法名、字段名等）替换为直接引用（具体的内存地址或偏移量）。</li>
</ul>
<h3 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h3><ul>
<li>一个字符串，这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</li>
<li>与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。</li>
<li>各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</li>
</ul>
<h3 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h3><ul>
<li>指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p> 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p>
<ul>
<li>对类变量初始化，是执行类构造器的过程。</li>
</ul>
<h3 id="类构造器"><a href="#类构造器" class="headerlink" title="类构造器"></a>类构造器</h3><ul>
<li>初始化阶段是执行类构造器<client>方法的过程。</li>
<li><client>方法是由编译器自动收集类中的<strong>类变量的赋值操作</strong>和<strong>静态语句块中的语句</strong>合并而成的。</li>
<li>虚拟机会保证子<client>方法执行之前，父类 的<client>方法已经执行完毕。</li>
<li>如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>方法。</li>
<li>以下几种情况不会执行类初始化:<ul>
<li>通过<strong>子类引用父类的静态字段</strong>，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义<strong>对象数组</strong>，不会触发该类的初始化。</li>
<li><strong>常量</strong>在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类的初始化。</li>
<li>通过<strong>类名获取 Class 对象</strong>，不会触发类的初始化。</li>
<li>通过 <strong>Class.forName 方法</strong>加载指定类，如果指定参数 initialize 为 false 时，也不会触发类初始化（这个参数是告诉虚拟机，是否要对类进行初始化）。</li>
<li>通过 <strong>ClassLoader 默认的 loadClass 方法</strong>，不会触发该类的初始化。</li>
</ul>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>加载动作在  JVM 外部实现，以便让应用程序决定如何获取所需的类。</li>
</ul>
<p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/IMG_2E0E61ED56CE-1.jpeg" alt="IMG_2E0E61ED56CE-1"></p>
<h3 id="启动类加载器-Bootstrap-ClassLoader"><a href="#启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动类加载器(Bootstrap ClassLoader)"></a>启动类加载器(Bootstrap ClassLoader)</h3><ul>
<li>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且 虚拟机认可的类。</li>
</ul>
<h3 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h3><ul>
<li>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</li>
</ul>
<h3 id="应用程序类加载器-Application-ClassLoader"><a href="#应用程序类加载器-Application-ClassLoader" class="headerlink" title="应用程序类加载器(Application ClassLoader)"></a>应用程序类加载器(Application ClassLoader)</h3><ul>
<li>负责加载用户路径(classpath)上的类库。</li>
</ul>
<h3 id="自定义加载器（User-ClassLoader）"><a href="#自定义加载器（User-ClassLoader）" class="headerlink" title="自定义加载器（User ClassLoader）"></a>自定义加载器（User ClassLoader）</h3><ul>
<li>通过继承 <strong>java.lang.ClassLoader</strong> 实现。</li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ul>
<li>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求<strong>委派给父类</strong>去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器。</li>
<li>只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的Class)，子类加载器才会尝试自己去加载。</li>
<li>好处是不管是哪个加载器加载同一个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个 Object 对象。</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Source Code</title>
    <url>/post/547eead8.html</url>
    <content><![CDATA[<h1 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h1><h2 id="Object-1"><a href="#Object-1" class="headerlink" title="Object 1"></a>Object 1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">      <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timeout++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="String-1"><a href="#String-1" class="headerlink" title="String 1"></a>String 1</h2><ul>
<li>jdk1.8及以前String使用的是char数组，jdk1.9及以后使用的是byte数组。</li>
<li>拥有equals()和hashcode()方法</li>
</ul>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Equals"><a href="#Equals" class="headerlink" title="Equals()"></a>Equals()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AbstractStringBuilder-1"><a href="#AbstractStringBuilder-1" class="headerlink" title="AbstractStringBuilder 1"></a>AbstractStringBuilder 1</h2><h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	System.arraycopy(value, start+len, value, start, count-end);</span><br><span class="line">	count -= len;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="str-getChars"><a href="#str-getChars" class="headerlink" title="str.getChars"></a>str.getChars</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">// str.getChars(0, len, value, start);</span></span><br><span class="line">	str.getChars(value, start);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Surrogate-Pairs"><a href="#Surrogate-Pairs" class="headerlink" title="Surrogate Pairs"></a>Surrogate Pairs</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseAllValidSurrogatePairs</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> value[i];</span><br><span class="line">        <span class="keyword">if</span> (Character.isLowSurrogate(c2)) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> value[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (Character.isHighSurrogate(c1)) &#123;</span><br><span class="line">                value[i++] = c1;</span><br><span class="line">                value[i] = c2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Unicode</li>
</ul>
<h2 id="StringBuffer-1"><a href="#StringBuffer-1" class="headerlink" title="StringBuffer 1"></a>StringBuffer 1</h2><ul>
<li>Multiple Threads</li>
</ul>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure>

<ol>
<li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li>
<li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li>
<li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</li>
</ol>
<h2 id="StringBuilder-1"><a href="#StringBuilder-1" class="headerlink" title="StringBuilder 1"></a>StringBuilder 1</h2><ul>
<li>Single Thread</li>
<li>线程不安全，但效率高</li>
</ul>
<h2 id="StringLatin1"><a href="#StringLatin1" class="headerlink" title="StringLatin1"></a>StringLatin1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">byte</span>[] value, <span class="type">int</span> valueCount, <span class="type">byte</span>[] str, <span class="type">int</span> strCount, <span class="type">int</span> fromIndex)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">first</span> <span class="operator">=</span> str[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (valueCount - strCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">// Look for first character.</span></span><br><span class="line">        <span class="keyword">if</span> (value[i] != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; value[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Found first character, now look at the rest of value</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j + strCount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; end &amp;&amp; value[j] == str[k]; j++, k++);</span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">// Found whole string.</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Boolean-2"><a href="#Boolean-2" class="headerlink" title="Boolean 2"></a>Boolean 2</h2><h3 id="getBoolean-String-name"><a href="#getBoolean-String-name" class="headerlink" title="getBoolean(String name)"></a>getBoolean(String name)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getBoolean</span><span class="params">(String name)</span> &#123;    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="keyword">try</span> &#123;        result = parseBoolean(System.getProperty(name));    &#125; <span class="keyword">catch</span> (IllegalArgumentException | NullPointerException e) &#123;    &#125;    <span class="keyword">return</span> result;&#125;</span><br></pre></td></tr></table></figure>

<p>当且仅当以参数命名的系统属性存在，且等于 “true” 字符串时，才返回 true。</p>
<ol start="7">
<li><p>Byte 2</p>
</li>
<li><p>Double 2</p>
</li>
<li><p>Float 2</p>
</li>
<li><p>Integer 2</p>
</li>
<li><p>Long 2</p>
</li>
<li><p>Short 2</p>
</li>
</ol>
<h2 id="Thread-2"><a href="#Thread-2" class="headerlink" title="Thread 2"></a>Thread 2</h2><h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;<span class="keyword">static</span> &#123;    registerNatives();&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>编写带有native声明的方法的Java类（java文件）</li>
<li>使用javac命令编译编写的Java类（class文件）</li>
<li>使用javah -jni 来生成后缀名为.h的头文件（.h的文件）</li>
<li>使用其他语言（C、C++）实现本地方法</li>
<li>将本地方法编写的文件生成动态链接库（dll文件）</li>
</ol>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>();&#125;</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><blockquote>
<p>Waits at most millis milliseconds for this thread to die.</p>
</blockquote>
<p>主线程等待wait()当前子线程运行结束。</p>
<ol start="14">
<li><p>ThreadLocal 2</p>
</li>
<li><p>Enum 3</p>
</li>
<li><p>Throwable 3</p>
</li>
<li><p>Error 3</p>
</li>
<li><p>Exception 3</p>
</li>
<li><p>Class 4</p>
</li>
<li><p>ClassLoader 4</p>
</li>
<li><p>Compiler 4</p>
</li>
<li><p>System 4</p>
</li>
<li><p>Package 4</p>
</li>
<li><p>Void 4</p>
</li>
</ol>
<h1 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h1><h2 id="AbstractList-1"><a href="#AbstractList-1" class="headerlink" title="AbstractList 1"></a>AbstractList 1</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>唯一的抽象方法</li>
</ul>
<h2 id="AbstractMap-1"><a href="#AbstractMap-1" class="headerlink" title="AbstractMap 1"></a>AbstractMap 1</h2><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AbstractSet-1"><a href="#AbstractSet-1" class="headerlink" title="AbstractSet 1"></a>AbstractSet 1</h2><h2 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList 1"></a>ArrayList 1</h2><h3 id="EMPTY-ELEMENTDATA"><a href="#EMPTY-ELEMENTDATA" class="headerlink" title="EMPTY_ELEMENTDATA"></a>EMPTY_ELEMENTDATA</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;    <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;  &#125; <span class="keyword">else</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+                                       initialCapacity);  &#125;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;  <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>EMPTY_ELEMENTDATA，优化创建ArrayList空实例时产生不必要的空数组，使得所有ArrayList空实例都指向同一个空数组。</li>
<li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA，确保无参构成函数创建的实例在添加第一个元素时，最小的容量是默认大小10。</li>
</ul>
<h3 id="MAX-ARRAY-SIZE"><a href="#MAX-ARRAY-SIZE" class="headerlink" title="MAX_ARRAY_SIZE"></a>MAX_ARRAY_SIZE</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h3 id="grow-int-minCapacity"><a href="#grow-int-minCapacity" class="headerlink" title="grow(int minCapacity)"></a>grow(int minCapacity)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);jdk1<span class="number">.6</span>:<span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>最小容量扩容至原有的1.5倍</li>
<li>考虑了可能的整型溢出问题</li>
</ul>
<blockquote>
<p>minCapacity is usually close to size, so this is a win</p>
</blockquote>
<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This method acts as bridge between array-based and collection-based APIs.</p>
</blockquote>
<h3 id="elementData-–size-x3D-null"><a href="#elementData-–size-x3D-null" class="headerlink" title="elementData[–size] &#x3D; null;"></a>elementData[–size] &#x3D; null;</h3><blockquote>
<p>clear to let GC do its work</p>
</blockquote>
<ul>
<li>为了让GC起作用，必须显式的为最后一个位置赋值null。</li>
</ul>
<h3 id="SubList"><a href="#SubList" class="headerlink" title="SubList"></a>SubList</h3><blockquote>
<p>Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;    subListRangeCheck(fromIndex, toIndex, size);    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, <span class="number">0</span>, fromIndex, toIndex);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>subList方法返回的是一个视图SubList，即对源列表的映射，如果对其进行编辑操作，源列表也会受到影响。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SubList</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span> &#123;		<span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;  	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parentOffset;  	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;  	<span class="type">int</span> size;  	...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SubList是一个ArrayList的内部类。</li>
<li>SubList中没有数组、列表等属性来存储数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;  	<span class="keyword">if</span> (ArrayList.<span class="built_in">this</span>.modCount != <span class="built_in">this</span>.modCount)    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SubList进行添加、删除元素会抛出异常ConcurrentModificationException，触发fail-fast机制。</li>
</ul>
<h2 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList 1"></a>LinkedList 1</h2><h3 id="node-int-index"><a href="#node-int-index" class="headerlink" title="node(int index)"></a>node(int index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;    <span class="comment">// assert isElementIndex(index);    if (index &lt; (size &gt;&gt; 1)) &#123;        Node&lt;E&gt; x = first;        for (int i = 0; i &lt; index; i++)            x = x.next;        return x;    &#125; else &#123;        Node&lt;E&gt; x = last;        for (int i = size - 1; i &gt; index; i--)            x = x.prev;        return x;    &#125;&#125;public E get(int index) &#123;  checkElementIndex(index);  return node(index).item;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断index位于链表前半部分还是后半部分</li>
</ul>
<h3 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst()"></a>removeFirst()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;  <span class="keyword">return</span> removeFirst();&#125;<span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;  <span class="keyword">return</span> removeFirst();&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;  <span class="keyword">return</span> remove(o);&#125;<span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;    <span class="keyword">final</span> Node&lt;E&gt; f = first;    <span class="keyword">if</span> (f == <span class="literal">null</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();    <span class="keyword">return</span> unlinkFirst(f);&#125;<span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;		...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>公私分明</li>
</ul>
<h3 id="addLast-E-e"><a href="#addLast-E-e" class="headerlink" title="addLast(E e)"></a>addLast(E e)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;    linkLast(e);&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  linkLast(e);  <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isElementIndex-int-index"><a href="#isElementIndex-int-index" class="headerlink" title="isElementIndex(int index)"></a>isElementIndex(int index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Tells if the argument is the index of an existing element. */</span><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;&#125;<span class="comment">/** * Tells if the argument is the index of a valid position for an * iterator or an add operation. */</span><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap 1"></a>HashMap 1</h2><h3 id="DEFAULT-INITIAL-CAPACITY"><a href="#DEFAULT-INITIAL-CAPACITY" class="headerlink" title="DEFAULT_INITIAL_CAPACITY"></a>DEFAULT_INITIAL_CAPACITY</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认容量，也即数组长度。</li>
<li>容量必须是2的次数幂，因为在查找hash地址时，会进行取模位运算。</li>
</ul>
<h3 id="TREEIFY-THRESHOLD"><a href="#TREEIFY-THRESHOLD" class="headerlink" title="TREEIFY_THRESHOLD"></a>TREEIFY_THRESHOLD</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当链表长度超过阈值时，会将链表转换为红黑树，使HashMap的性能得到进一步提升。</li>
</ul>
<h3 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;    <span class="type">int</span> h;    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>key值进行hashcode以后，进行相与时候都是只用到了后四位，前面的很多位都没有能够得到使用,这样也可能会导致生成的下标值不能够完全散列。</li>
<li>将生成的hashcode值的高16位于低16位进行异或运算，这样得到的值再进行相与，得到最散列的下标值。</li>
</ul>
<h3 id="tableSizeFor-int-cap"><a href="#tableSizeFor-int-cap" class="headerlink" title="tableSizeFor(int cap)"></a>tableSizeFor(int cap)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;    n |= n &gt;&gt;&gt; <span class="number">1</span>;    n |= n &gt;&gt;&gt; <span class="number">2</span>;    n |= n &gt;&gt;&gt; <span class="number">4</span>;    n |= n &gt;&gt;&gt; <span class="number">8</span>;    n |= n &gt;&gt;&gt; <span class="number">16</span>;    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反复操作把每一位数变成1。</li>
<li>最后+1变成最近的2多整数次幂。</li>
</ul>
<h3 id="i-x3D-n-1-amp-hash"><a href="#i-x3D-n-1-amp-hash" class="headerlink" title="i &#x3D; (n - 1) &amp; hash"></a>i &#x3D; (n - 1) &amp; hash</h3><p>$$<br>(n - 1) &amp; hash &#x3D; hash % n<br>$$</p>
<ul>
<li>n为2多整数次幂，n-1即为全1位数。</li>
</ul>
<p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NQcmltZXIw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<h3 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</h3><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NQcmltZXIw,size_16,color_FFFFFF,t_70-20210811104418939.png" alt="在这里插入图片描述"></p>
<h2 id="Hashtable-1"><a href="#Hashtable-1" class="headerlink" title="Hashtable 1"></a>Hashtable 1</h2><blockquote>
<p> it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.</p>
</blockquote>
<h3 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;    <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);&#125;<span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认的初始大小为11，之后每次扩充为原来的2n+1。</li>
<li>会尽量使用素数、奇数作为容量的大小，使得简单取模的哈希结果会更加均匀。</li>
</ul>
<h3 id="abstract-class-Dictionary-lt-K-V-gt"><a href="#abstract-class-Dictionary-lt-K-V-gt" class="headerlink" title="abstract class Dictionary&lt;K,V&gt;"></a>abstract class Dictionary&lt;K,V&gt;</h3><ul>
<li>已过时</li>
</ul>
<blockquote>
<p>This class is obsolete. New implementations should implement the Map interface, rather than extending this class.</p>
</blockquote>
<h3 id="interface-Enumeration-lt-E-gt"><a href="#interface-Enumeration-lt-E-gt" class="headerlink" title="interface Enumeration&lt;E&gt;"></a>interface Enumeration&lt;E&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;    <span class="keyword">return</span> <span class="built_in">this</span>.&lt;K&gt;getEnumeration(KEYS);&#125;<span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title function_">elements</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="built_in">this</span>.&lt;V&gt;getEnumeration(VALUES);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>已被迭代器重写，甚少被使用。</li>
</ul>
<blockquote>
<p>The functionality of this interface is duplicated by the Iterator interface.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Iterator&lt;E&gt; <span class="title function_">asIterator</span><span class="params">()</span> &#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;            <span class="keyword">return</span> hasMoreElements();        &#125;        <span class="meta">@Override</span> <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;            <span class="keyword">return</span> nextElement();        &#125;    &#125;;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用方法asIterator()转换为迭代器。</li>
</ul>
<blockquote>
<p>It is possible to adapt an Enumeration to an Iterator by using the asIterator method.</p>
</blockquote>
<h3 id="hash-amp-0x7FFFFFFF-tab-length"><a href="#hash-amp-0x7FFFFFFF-tab-length" class="headerlink" title="(hash &amp; 0x7FFFFFFF) % tab.length"></a>(hash &amp; 0x7FFFFFFF) % tab.length</h3><ul>
<li>相比hashmap，采用了直接取模。</li>
<li>hash值和0x7FFFFFFF进行一次按位与操作，是为了保证得到的index的第一位为0，也就是为了得到一个有符号正数。</li>
</ul>
<h2 id="HashSet-1"><a href="#HashSet-1" class="headerlink" title="HashSet 1"></a>HashSet 1</h2><h3 id="PRESENT"><a href="#PRESENT" class="headerlink" title="PRESENT"></a>PRESENT</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个static finall的Object对象作为HashMap的虚拟的value。</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);&#125;<span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;  map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只被用来创建LinkedHashSet的私有方法。</li>
<li>dummy参数用来区分其他(int float)构造函数</li>
</ul>
<h2 id="LinkedHashMap-1"><a href="#LinkedHashMap-1" class="headerlink" title="LinkedHashMap 1"></a>LinkedHashMap 1</h2><h3 id="accessOrder"><a href="#accessOrder" class="headerlink" title="accessOrder"></a>accessOrder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;<span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;    <span class="built_in">super</span>();    accessOrder = <span class="literal">false</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>accessOrder&#x3D;false，按照插入元素的顺序遍历元素。</li>
<li>accessOrder&#x3D;true，按照访问元素的顺序，即可实现最近最少使用策略(Least Recently Used，LRU)。</li>
</ul>
<h3 id="removeEldestEntry-Map-Entry-lt-K-V-gt-eldest"><a href="#removeEldestEntry-Map-Entry-lt-K-V-gt-eldest" class="headerlink" title="removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)"></a>removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>移除最早加入的Entry。</li>
<li>默认不使用，但允许覆写。</li>
</ul>
<h3 id="afterNodeAccess-Node-lt-K-V-gt-e"><a href="#afterNodeAccess-Node-lt-K-V-gt-e" class="headerlink" title="afterNodeAccess(Node&lt;K,V&gt; e)"></a>afterNodeAccess(Node&lt;K,V&gt; e)</h3><ul>
<li>在节点访问之后被调用，主要在put()已经存在的元素或get()时。</li>
<li>如果accessOrder&#x3D;true，把当前访问节点移动到双向链表的末尾。</li>
</ul>
<h2 id="LinkedHashSet-1"><a href="#LinkedHashSet-1" class="headerlink" title="LinkedHashSet 1"></a>LinkedHashSet 1</h2><h3 id="LinkedHashMap-1"><a href="#LinkedHashMap-1" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);&#125;HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;  map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>底层调用LinkedHashMap实现。</li>
</ul>
<h2 id="TreeMap-1"><a href="#TreeMap-1" class="headerlink" title="TreeMap 1"></a>TreeMap 1</h2><ul>
<li><p>继承NavigableMap，提供访问给定搜索目标的最接近匹配项的导航方法。</p>
</li>
<li><p>继承SortedMap，保证key有序性。</p>
</li>
</ul>
<h2 id="TreeSet-1"><a href="#TreeSet-1" class="headerlink" title="TreeSet 1"></a>TreeSet 1</h2><ul>
<li>底层为TreeMap</li>
</ul>
<h2 id="Vector-2"><a href="#Vector-2" class="headerlink" title="Vector 2"></a>Vector 2</h2><ul>
<li>线程安全，开销增大</li>
</ul>
<h2 id="Queue-2"><a href="#Queue-2" class="headerlink" title="Queue 2"></a>Queue 2</h2><ul>
<li>继承自Collection</li>
<li>提供两类方法</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Returns special value</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<h2 id="Stack-2"><a href="#Stack-2" class="headerlink" title="Stack 2"></a>Stack 2</h2><ul>
<li>继承自Vector</li>
<li>建议使用Deque</li>
</ul>
<h2 id="SortedMap-2"><a href="#SortedMap-2" class="headerlink" title="SortedMap 2"></a>SortedMap 2</h2><ul>
<li>提供有序性的方法</li>
</ul>
<h2 id="SortedSet-2"><a href="#SortedSet-2" class="headerlink" title="SortedSet 2"></a>SortedSet 2</h2><h3 id="Spliterators"><a href="#Spliterators" class="headerlink" title="Spliterators"></a>Spliterators</h3><ul>
<li>并行迭代器</li>
</ul>
<h2 id="Collections-3"><a href="#Collections-3" class="headerlink" title="Collections 3"></a>Collections 3</h2><h3 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt;<span class="type">int</span> <span class="title function_">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;    <span class="keyword">while</span> (low &lt;= high) &#123;        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;        Comparable&lt;? <span class="built_in">super</span> T&gt; midVal = list.get(mid);        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> midVal.compareTo(key);        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)            low = mid + <span class="number">1</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)            high = mid - <span class="number">1</span>;        <span class="keyword">else</span>            <span class="keyword">return</span> mid; <span class="comment">// key found    &#125;    return -(low + 1);  // key not found&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Arrays 3</li>
<li>Comparator 3</li>
<li>Iterator 3</li>
<li>Base64 4</li>
<li>Date 4</li>
<li>EventListener 4</li>
<li>Random 4</li>
<li>SubList 4</li>
<li>Timer 4</li>
<li>UUID 4</li>
<li>WeakHashMap 4</li>
</ol>
<p>3、java.util.concurrent</p>
<ol>
<li><p>ConcurrentHashMap 1</p>
</li>
<li><p>Executor 2</p>
</li>
<li><p>AbstractExecutorService 2</p>
</li>
<li><p>ExecutorService 2</p>
</li>
<li><p>ThreadPoolExecutor 2</p>
</li>
<li><p>BlockingQueue 2</p>
</li>
</ol>
<p>7）AbstractQueuedSynchronizer 2</p>
<p>8）CountDownLatch 2</p>
<ol start="9">
<li>FutureTask 2</li>
</ol>
<p>10）Semaphore 2</p>
<p>11）CyclicBarrier 2</p>
<p>13）CopyOnWriteArrayList 3</p>
<p>14）SynchronousQueue 3</p>
<p>15）BlockingDeque 3</p>
<ol start="16">
<li>Callable 4</li>
</ol>
<p>4、java.util.concurrent.atomic</p>
<ol>
<li><p>AtomicBoolean 2</p>
</li>
<li><p>AtomicInteger 2</p>
</li>
<li><p>AtomicLong 2</p>
</li>
<li><p>AtomicReference 3</p>
</li>
</ol>
<p>5、java.lang.reflect</p>
<ol>
<li><p>Field 2</p>
</li>
<li><p>Method 2</p>
</li>
</ol>
<p>6、java.lang.annotation</p>
<ol>
<li><p>Annotation 3</p>
</li>
<li><p>Target 3</p>
</li>
<li><p>Inherited 3</p>
</li>
<li><p>Retention 3</p>
</li>
<li><p>Documented 4</p>
</li>
<li><p>ElementType 4</p>
</li>
<li><p>Native 4</p>
</li>
<li><p>Repeatable 4</p>
</li>
</ol>
<p>7、java.util.concurrent.locks</p>
<ol>
<li><p>Lock 2</p>
</li>
<li><p>Condition 2</p>
</li>
<li><p>ReentrantLock 2</p>
</li>
<li><p>ReentrantReadWriteLock 2</p>
</li>
</ol>
<p>8、java.io</p>
<ol>
<li><p>File 3</p>
</li>
<li><p>InputStream  3</p>
</li>
<li><p>OutputStream 3</p>
</li>
<li><p>Reader 4</p>
</li>
<li><p>Writer 4</p>
</li>
</ol>
<p>9、java.nio</p>
<ol>
<li><p>Buffer 3</p>
</li>
<li><p>ByteBuffer 4</p>
</li>
<li><p>CharBuffer 4</p>
</li>
<li><p>DoubleBuffer 4</p>
</li>
<li><p>FloatBuffer 4</p>
</li>
<li><p>IntBuffer 4</p>
</li>
<li><p>LongBuffer 4</p>
</li>
<li><p>ShortBuffer 4</p>
</li>
</ol>
<p>10、java.sql</p>
<ol>
<li><p>Connection 3</p>
</li>
<li><p>Driver 3</p>
</li>
<li><p>DriverManager 3</p>
</li>
<li><p>JDBCType 3</p>
</li>
<li><p>ResultSet 4</p>
</li>
<li><p>Statement 4</p>
</li>
</ol>
<p>11、java.net</p>
<ol>
<li><p>Socket 3</p>
</li>
<li><p>ServerSocket 3</p>
</li>
<li><p>URI 4</p>
</li>
<li><p>URL 4</p>
</li>
<li><p>URLEncoder 4</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java</title>
    <url>/post/df2849ec.html</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。</p>
<p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决一个全局使用的类频繁地创建与销毁。</p>
<span id="more"></span>

<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">newInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的构造函数定义为private，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。</p>
<p>饿汉模式是最简单的一种实现方式，饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。</p>
<p>它的好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。</p>
<p>它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。</p>
<p>这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大，或单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了，这时候就需要用到懒汉模式进行延迟加载。</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">newInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。</p>
<p>如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择。</p>
<p>但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题，但加锁会影响效率。</p>
<h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在同步代码块外多了一层instance为空的判断。由于单例对象只需要创建一次，如果后面再次调用getInstance()只需要直接返回单例对象。因此，大部分情况下，调用getInstance()都不会执行到同步代码块，从而提高了程序性能。</p>
<p>不过还需要考虑一种情况，假如两个线程A、B，A执行了if (instance &#x3D;&#x3D; null)语句，它会认为单例对象没有创建，此时线程切到B也执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象。为了解决这个问题，还需要在同步代码块中增加if (instance &#x3D;&#x3D; null)语句。</p>
<p>这里要提到Java中的指令重排优化。所谓指令重排优化是指在不改变原语义的情况下，通过调整指令的执行顺序让程序运行的更快。JVM中并没有规定编译器优化相关的内容，也就是说JVM可以自由的进行指令重排序的优化。</p>
<p>这个问题的关键就在于由于指令重排优化的存在，导致初始化Singleton和将对象地址赋给instance字段的顺序是不确定的。在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对象的字段设置为默认值。此时就可以将分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化，若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。</p>
<p>在JDK1.5及之后版本增加了volatile关键字volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的，从而避免改该问题。</p>
<h3 id="登记式-x2F-静态内部类"><a href="#登记式-x2F-静态内部类" class="headerlink" title="登记式&#x2F;静态内部类"></a>登记式&#x2F;静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
<p>这种方式是  Singleton 类被装载了，instance 不一定被初始化，利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。不一样的是，它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	instance;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span>&#123;&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而枚举类很好的解决了两个问题：不需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例；其次可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。</p>
<p>使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。</p>
<p>枚举方式虽然很完美的解决了各种问题，但是这种写法多少让人感觉有些生疏。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
<li>不保证原子性</li>
</ol>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ol>
<li>当我们调用 shutdown 等方法关闭线程池后，如果再向线程池内提交任务，就会遭到拒绝。</li>
<li>线程池没有空闲线程（线程池的线程达到了最大线程数，并且都在执行任务）并且队列已经满了，不能在存放任务了。</li>
</ol>
<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p>
<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>当有新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</p>
<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>丢弃任务队列中的头结点，通常是存活时间最长的任务，它也存在一定的数据丢失风险。</p>
<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>第四种拒绝策略是 ，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p>
<p>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。 第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</p>
<h2 id="Hash-Map-x2F-Hash-Table"><a href="#Hash-Map-x2F-Hash-Table" class="headerlink" title="Hash Map&#x2F;Hash Table"></a>Hash Map&#x2F;Hash Table</h2><h2 id="构造器，构造代码块，静态代码块的执行顺序"><a href="#构造器，构造代码块，静态代码块的执行顺序" class="headerlink" title="构造器，构造代码块，静态代码块的执行顺序"></a>构造器，构造代码块，静态代码块的执行顺序</h2><h2 id="string，stringbuilder和stringbuffer的区别"><a href="#string，stringbuilder和stringbuffer的区别" class="headerlink" title="string，stringbuilder和stringbuffer的区别"></a>string，stringbuilder和stringbuffer的区别</h2><h1 id="NIO-x2F-IO"><a href="#NIO-x2F-IO" class="headerlink" title="NIO&#x2F;IO"></a>NIO&#x2F;IO</h1>]]></content>
      <categories>
        <category>Tech</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Internship Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka-Config</title>
    <url>/post/797e84b7.html</url>
    <content><![CDATA[<h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>bootstrap.servers</td>
<td>服务地址</td>
<td></td>
</tr>
<tr>
<td>key.deserializer</td>
<td>消息 Key 的反序列化方式</td>
<td></td>
</tr>
<tr>
<td>value.deserializer</td>
<td>消息 Value 的反序列化方式</td>
<td></td>
</tr>
<tr>
<td>group.id</td>
<td>消费组 ID</td>
<td>“”</td>
</tr>
<tr>
<td>auto.offset.reset</td>
<td>offset 重置方式<br/>- earliest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费。<br/>- latest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据。<br/>- none：topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常<br/>- anything else：抛出异常</td>
<td>latest</td>
</tr>
<tr>
<td>enable.auto.commit</td>
<td>offset 提交方式<br/>- true：自动提交<br/>- false：手动提交</td>
<td>true</td>
</tr>
<tr>
<td>max.poll.interval.ms</td>
<td>使用消费组管理时的的拉取时间间隔</td>
<td>300000</td>
</tr>
<tr>
<td>max.poll.records</td>
<td>一次拉取时的最大记录数</td>
<td>500</td>
</tr>
<tr>
<td>sasl.mechanism</td>
<td>用于客户端连接的 SASL 机制（一般用 PLAIN）</td>
<td>GSSAPI</td>
</tr>
<tr>
<td>security.protocol</td>
<td>连接 broker 的协议<br/>- PLAINTEXT<br/>- SSL<br/>- SASL_PLAINTEXT<br/>- SASL_SSL</td>
<td>PLAINTEXT</td>
</tr>
</tbody></table>
<h1 id="Spring-Kafka-Listener"><a href="#Spring-Kafka-Listener" class="headerlink" title="Spring-Kafka-Listener"></a>Spring-Kafka-Listener</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>spring.kafka.listener.ack-mode</td>
<td>提交 offset 方式<br/>spring-kafak负责提交：<br/>- record：每处理一个消息，就提交一次<br/>- batch：将上一次poll得到消息进行提交<br/>- time：达到指定时间间隔，就提交<br/>- count：达到指定次数，就提交<br/>- count_time：达到指定次数和间间隔，就提交<br/>手动提交：<br/>- manual：调用后先存放至本地缓存，在下一次poll之前取出批量提交<br/>- manual_immediate：调用后立即提交</td>
<td></td>
</tr>
</tbody></table>
<h1 id="Authentication-using-SASL-x2F-PLAIN"><a href="#Authentication-using-SASL-x2F-PLAIN" class="headerlink" title="Authentication using SASL&#x2F;PLAIN"></a>Authentication using SASL&#x2F;PLAIN</h1><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><ol>
<li><p>在每一个 Kafka broker 的 config 目录中, 添加一个 JAAS 文件：<code>kafka_server_jaas.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KafkaServer &#123;</span><br><span class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">    username=&quot;admin&quot;</span><br><span class="line">    password=&quot;admin-secret&quot;</span><br><span class="line">    user_admin=&quot;admin-secret&quot;</span><br><span class="line">    user_alice=&quot;alice-secret&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 JAAS 配置文件的路径作为 JVM 的参数, 并传递到每一个 Kafka broker</p>
<ol>
<li>&#96;&#96;&#96;shell<br>-Djava.security.auth.login.config&#x3D;&#x2F;etc&#x2F;kafka&#x2F;kafka_server_jaas.conf<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 在 server.properties 中配置 SASL 端口和 SASL 机制</span><br><span class="line"></span><br><span class="line">   ```properties</span><br><span class="line">   listeners=SASL_SSL://host.name:port</span><br><span class="line">   security.inter.broker.protocol=SASL_SSL</span><br><span class="line">   sasl.mechanism.inter.broker.protocol=PLAIN</span><br><span class="line">   sasl.enabled.mechanisms=PLAIN</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sasl.jaas.config</span>=<span class="string">org.apache.kafka.common.security.plain.PlainLoginModule required \</span></span><br><span class="line"><span class="string">	username=&quot;alice&quot; \</span></span><br><span class="line"><span class="string">	password=&quot;alice-secret&quot;;</span></span><br><span class="line"><span class="attr">security.protocol</span>=<span class="string">SASL_SSL</span></span><br><span class="line"><span class="attr">sasl.mechanism</span>=<span class="string">PLAIN</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://kafka.apache.org/documentation.html#consumerconfigs">https://kafka.apache.org/documentation.html#consumerconfigs</a></li>
<li><a href="https://kafka.apachecn.org/documentation.html#consumerconfigs">https://kafka.apachecn.org/documentation.html#consumerconfigs</a></li>
<li><a href="https://kafka.apachecn.org/documentation.html#adminclientconfigs">https://kafka.apachecn.org/documentation.html#adminclientconfigs</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/post/9a7d5a13.html</url>
    <content><![CDATA[<blockquote>
<p>Apache Kafka 是一个分布式流处理平台。</p>
<ul>
<li>Kafka 作为一个集群，运行在一台或者多台服务器上.</li>
<li>Kafka 通过 <em>topic</em> 对存储的流数据进行分类。</li>
<li>每条记录中包含一个key，一个value和一个timestamp（时间戳）。</li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/image-20220418164101024.png" alt="image-20220418164101024"></p>
<ul>
<li>生产者（Producer）</li>
<li>消费者（Consumer）</li>
<li>还有用来做数据集成的 Kafka Connect API 和流式处理的 Kafka Streams 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，它们只不过是在上层做了封装。</li>
</ul>
<h1 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h1><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/image-20220418164225275.png" alt="image-20220418164225275"></p>
<ul>
<li>Kafka 中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到 Kafka 集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。</li>
<li>主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。</li>
<li>offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，Kafka 保证的是分区有序而不是主题有序。</li>
</ul>
<h1 id="节点（Broker）"><a href="#节点（Broker）" class="headerlink" title="节点（Broker）"></a>节点（Broker）</h1><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/image-20220418164341950.png" alt="image-20220418164341950"></p>
<ul>
<li>Kafka 中的一台或多台服务器统称 broker。</li>
<li><strong>Kafka</strong> 强依赖于 zookeeper ，每当一个 broker 启动时，它会将自己注册到 zookeeper 的临时节点；Kafka 利用 zookeeper 临时节点来管理 broker 生命周期。</li>
<li>若干个 Broker 组成一个集群（Cluster），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。</li>
<li>在集群内，一个分区 由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader。</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ul>
<li><p>Kafka 的消息是存在于文件系统之上的，其高度依赖文件系统来存储和缓存消息。</p>
</li>
<li><p>相比 Topic 是逻辑上的概念，物理上的存储的其实是 Partition，每一个 Partition 最终对应一个目录，里面存储所有的消息和索引文件。默认情况下，每一个 Topic 在创建时如果不指定 Partition 数量时只会创建 1 个 Partition。命名规则是：<code>&lt;topic_name&gt;-&lt;partition_id&gt;</code> 。</p>
</li>
<li><p>任何发布到 Partition 的消息都会被追加到 Partition 文件的尾部，这样的顺序写磁盘操作让 Kafka 的效率非常高。</p>
</li>
<li><p>每一条被发送到 Broker 的消息，会根据规则被存储到具体的 Partition中。如果规则设置的合理，所有消息可以均匀分布到不同的 Partition 中。</p>
</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul>
<li>解耦</li>
<li>异步</li>
<li>削峰</li>
</ul>
<h1 id="并行度"><a href="#并行度" class="headerlink" title="并行度"></a>并行度</h1><ul>
<li>把一个 topic 分成多个分区，并把多个消费者组成一个消费组，由消费者组去处理该 topic 的数据。</li>
<li>不同的消费者可以实时的处理同一个 topic 中的不同的 partition 中的数据。</li>
</ul>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><ul>
<li>topic 的每个 partition 存在于不同的 broker 上，topic 的数据，是分散放在多个机器上的，每个机器存放一部分数据。</li>
<li>Kafka 0.8 以后，提供 replica 副本机制：每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本；所有 replica 会选举一个 leader，其他 replica 就是 follower。</li>
<li>生产和消费均只与 leader 产生联系：<ul>
<li>写的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。</li>
<li>读的时候，消费者只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</li>
</ul>
</li>
<li>Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，提高容错性。</li>
<li>如果某个 broker 宕机了，该 broker 上面的 partition 在其他机器上都有副本。如果这个宕机的 broker 上面有某个 partition 的 leader，此时会从 follower 中重新选举一个新的 leader 出来，继续读写新的 leader 即可。</li>
</ul>
<h1 id="可靠性传输"><a href="#可靠性传输" class="headerlink" title="可靠性传输"></a>可靠性传输</h1><h2 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h2><ul>
<li>唯一可能导致消费者弄丢数据的情况——消费者自动提交 offset，但消费端因为某些原因未能消费数据。</li>
<li>关闭自动提交 offset，在处理完之后消费者手动提交 offset，就可以保证数据不会丢。</li>
<li>但此时可能会有重复消费，需要消费端自行保证幂等性。</li>
</ul>
<h2 id="Kafka-端"><a href="#Kafka-端" class="headerlink" title="Kafka 端"></a>Kafka 端</h2><ul>
<li>Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。如果此时其他的 follower 刚好还有些数据没有同步，导致部分数据丢失。</li>
<li>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li>
<li>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系。</li>
<li>在 producer 端设置 acks&#x3D;all ：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</li>
<li>在 producer 端设置 retries&#x3D;MAX （较大值）：要求一旦写入失败，就无限重试。</li>
</ul>
<h2 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h2><ul>
<li>设置 acks&#x3D;all ，一定不会丢。</li>
<li>你的 leader 接收到消息，所有的 follower 都同步到消息之后，才认为本次写成功；如果没满足这个条件，生产者会自动不断重试。</li>
</ul>
<h1 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h1><ol>
<li>如果auto.commit.enable&#x3D;true，当consumer fetch了一些数据但还没有完全处理掉的时候，刚好到commit interval出发了提交offset操作，接着consumer crash掉了。这时已经fetch的数据还没有处理完成但已经被commit掉，因此没有机会再次被处理，数据丢失。</li>
<li>网络负载很高或者磁盘很忙写入失败的情况下，没有自动重试重发消息。</li>
<li>如果磁盘坏了，会丢失已经落盘的数据</li>
<li>单批数据的长度超过限制会丢失数据，报kafka.common.MessageSizeTooLargeException异常</li>
<li>partition leader在未完成副本数follows的备份时就宕机的情况，即使选举出了新的leader但是已经push的数据因为未备份就丢失了</li>
<li>kafka的数据一开始就是存储在PageCache上的，定期flush到磁盘上的，也就是说，不是每个消息都被存储在磁盘了，如果出现断电或者机器故障等，PageCache上的数据就丢失了。</li>
<li>由于Kafka consumer默认是自动提交位移的，所以如果在消息处理完成前就提交了offset，那么就有可能造成数据的丢失。</li>
</ol>
<h2 id="Producer-端"><a href="#Producer-端" class="headerlink" title="Producer 端"></a>Producer 端</h2><ol>
<li>replication.factor，副本的数量，至少大于1；</li>
<li>min.insync.replications，必须大于1，要求每个leader至少感知到有一个follower和自己保持同步；</li>
<li>ack &#x3D; all，确保每个数据必须是写入了所有副本之后，才算写成功；</li>
<li>retries，需要重新发送次数；</li>
<li>log.flush.interval.messages、log.flush.interval.ms，配置flush间隔。</li>
</ol>
<h2 id="Broker-端"><a href="#Broker-端" class="headerlink" title="Broker 端"></a>Broker 端</h2><p>topic设置多分区，分区自适应所在机器，为了让各分区均匀分布在所在的broker中，分区数要大于broker数。</p>
<p>分区是kafka进行并行读写的单位，是提升kafka速度的关键。</p>
<ol>
<li>broker能接收消息的最大字节数的设置一定要比消费端能消费的最大字节数要小，否则broker就会因为消费端无法使用这个消息而挂起。</li>
<li>broker可赋值的消息的最大字节数设置一定要比能接受的最大字节数大，否则broker就会因为数据量的问题无法复制副本，导致数据丢失。</li>
</ol>
<h2 id="Consumer-端"><a href="#Consumer-端" class="headerlink" title="Consumer 端"></a>Consumer 端</h2><ol>
<li>enable.auto.commit&#x3D;false ，关闭自动提交位移，并在消息被完整处理之后再手动提交位移。</li>
</ol>
<h1 id="低延迟高吞吐"><a href="#低延迟高吞吐" class="headerlink" title="低延迟高吞吐"></a>低延迟高吞吐</h1><h2 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h2><p>Kafka将消息记录持久化到本地磁盘中，实际上不管是内存还是磁盘，快或慢关键在于寻址的方式，基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高。</p>
<p>Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升 。每一个Partition其实都是一个文件 ，收到消息后Kafka会把数据插入到文件末尾。</p>
<p>同样这种方法不能删除数据 ，所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者Consumer对每个Topic都有一个offset用来表示读取到了第几条数据 。</p>
<p>如果不删除硬盘肯定会被撑满，所以Kakfa提供了两种策略来删除数据，一是基于时间，二是基于partition文件大小。</p>
<h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p>为了优化读写性能，Kafka利用了操作系统本身的Page Cache，即利用操作系统自身的内存而不是JVM空间内存。这样做的好处有：</p>
<ol>
<li>避免Object消耗：如果是使用 Java 堆，Java对象的内存消耗比较大，通常是所存储数据的两倍甚至更多。</li>
<li>避免GC问题：随着JVM中数据不断增多，垃圾回收将会变得复杂与缓慢，使用系统缓存就不会存在GC问题。</li>
</ol>
<p>相比于使用JVM或in-memory cache等数据结构，利用操作系统的Page Cache更加简单可靠。</p>
<p>首先，操作系统层面的缓存利用率会更高，因为存储的都是紧凑的字节结构而不是独立的对象。</p>
<p>其次，操作系统本身也对于Page Cache做了大量优化，提供了 write-behind、read-ahead以及flush等多种机制。</p>
<p>再者，即使服务进程重启，系统缓存依然不会消失，避免了in-process cache重建缓存的过程。</p>
<h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><p>当Kafka客户端从服务器读取数据时，如果不使用零拷贝技术，那么大致需要经历这样的一个过程：</p>
<ol>
<li>操作系统将数据从磁盘上读入到内核空间的读缓冲区中</li>
<li>应用程序（也就是Kafka）从内核空间的读缓冲区将数据拷贝到用户空间的缓冲区中</li>
<li>应用程序将数据从用户空间的缓冲区再写回到内核空间的socket缓冲区中</li>
<li>操作系统将socket缓冲区中的数据拷贝到NIC缓冲区中，然后通过网络发送给客户端</li>
</ol>
<p>Kafka使用零拷贝技术，即直接将数据从内核空间的读缓冲区直接拷贝到内核空间的socket缓冲区，然后再写入到NIC缓冲区，避免了在内核空间和用户空间之间穿梭。</p>
<p>零拷贝并非指一次拷贝都没有，而是避免了在内核空间和用户空间之间的拷贝。</p>
<h2 id="分区分段-索引"><a href="#分区分段-索引" class="headerlink" title="分区分段+索引"></a>分区分段+索引</h2><p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。符合分布式系统分区分桶的设计思想。</p>
<p>通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p>
<h2 id="批量读写"><a href="#批量读写" class="headerlink" title="批量读写"></a>批量读写</h2><p>Kafka数据读写是批量的而不是单条的。在向Kafka写入数据时，可以启用批次写入，这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。</p>
<h2 id="批量压缩"><a href="#批量压缩" class="headerlink" title="批量压缩"></a>批量压缩</h2><p>在很多情况下，系统的瓶颈不是CPU或磁盘，而是网络IO，对于需要在广域网上的数据中心之间发送消息的数据流水线尤其如此。如果每个消息都压缩，但是压缩率相对很低，所以Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩。<br>Kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩。Kafka把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗。</p>
<h1 id="蓄水池机制"><a href="#蓄水池机制" class="headerlink" title="蓄水池机制"></a>蓄水池机制</h1><p>生产的流程主要就是一个producer线程和一个sender线程，它们之间通过BatchQueue来获取数据，它们的关系是一一对应的，所以kafka的生产过程都是异步过程，它的同步和异步指的是接收响应结果的模式是同步阻塞还是异步回调。</p>
<p>同步接收是依据send之后返回Future，再调用Future的get方法进行阻塞等待。下面我们就从producer和sender两个类所对应的流程来进行分析，他们分别是消息收集过程和消息发送过程。消息的收集过程的数据最终是放在BatchQueue，像是将水流入了一个蓄水池的场景。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://blog.csdn.net/qq_34319644/article/details/96586147">https://blog.csdn.net/qq_34319644/article/details/96586147</a></li>
<li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/why-mq">https://doocs.github.io/advanced-java/#/docs/high-concurrency/why-mq</a></li>
<li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues">https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues</a></li>
<li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages">https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1787280">https://cloud.tencent.com/developer/article/1787280</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka-Deployment</title>
    <url>/post/47c475d4.html</url>
    <content><![CDATA[<blockquote>
<p>Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.</p>
</blockquote>
<span id="more"></span>

<h1 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h1><ul>
<li>官网：<a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></li>
</ul>
<h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><ul>
<li>启动脚本：<ul>
<li>Linux：文件夹<code>bin/</code></li>
<li>Windows：文件夹<code>bin/windows</code></li>
</ul>
</li>
<li>启动 Zookeeper：<code>bin/zookeeper-server-start.sh config/zookeeper.properties</code></li>
<li>启动 Kafka：<code>bin/kafka-server-start.sh config/server.properties</code></li>
</ul>
<h1 id="Spring-for-Kafka"><a href="#Spring-for-Kafka" class="headerlink" title="Spring for Kafka"></a>Spring for Kafka</h1><h2 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.auto-offset-reset</span>=<span class="string">earliest</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.group-id</span>=<span class="string">group</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.key-deserializer</span>=<span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.value-deserializer</span>=<span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"><span class="attr">spring.kafka.producer.key-serializer</span>=<span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="attr">spring.kafka.producer.value-serializer</span>=<span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br></pre></td></tr></table></figure>

<h3 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto-offset-reset"></a>auto-offset-reset</h3><ul>
<li>earliest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</li>
<li>latest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</li>
</ul>
<h2 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; template;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String topic, String message)</span> &#123;</span><br><span class="line">        template.send(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        template.send(AppConstant.TOPIC_NAME, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReceiveMessage"><a href="#ReceiveMessage" class="headerlink" title="ReceiveMessage"></a>ReceiveMessage</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(id = &quot;001&quot;, topics= AppConstant.TOPIC_NAME, groupId = AppConstant.GROUP_ID)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://kafka.apachecn.org/">https://kafka.apachecn.org</a></li>
<li><a href="https://kafka.apache.org/quickstart">https://kafka.apache.org/quickstart</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>Database</title>
    <url>/post/547eead8.html</url>
    <content><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），行锁定和外键，是默认的MySQL引擎。InnoDB主要特性有：</p>
<ol>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合。</li>
<li>InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的。</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。</li>
<li>InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件。</li>
</ol>
<span id="more"></span>

<h2 id="比较选择"><a href="#比较选择" class="headerlink" title="比较选择"></a>比较选择</h2><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/1200.png" alt="img"></p>
<p>如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择。</p>
<p>如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率。</p>
<p>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果。</p>
<p>如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive。</p>
<h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><h2 id="特性（ACID）"><a href="#特性（ACID）" class="headerlink" title="特性（ACID）"></a>特性（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离，每个事务都感觉不到有其他事务在并发地执行。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作，必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h2 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h2><p>在实际应用中，数据库中的数据是要被多个用户共同访问的，在多个用户同时操作相同的数据时，可能就会出现一些事务的并发问题，具体如下。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>指一个事务读取到另一个事务未提交的数据。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>指一个事务对同一行数据重复读取两次，但得到的结果不同。</p>
<h3 id="虚读-x2F-幻读"><a href="#虚读-x2F-幻读" class="headerlink" title="虚读&#x2F;幻读"></a>虚读&#x2F;幻读</h3><p>指一个事务执行两次查询，但第二次查询的结果包含了第一次查询中未出现的数据。</p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>指两个事务同时更新一行数据，后提交（或撤销）的事务将之前事务提交的数据覆盖了。</p>
<p> 丢失更新可分为两类：</p>
<ul>
<li>第一类丢失更新，指两个事务同时操作同一个数据时，当第一个事务撤销时，把已经提交的第二个事务的更新数据覆盖了，第二个事务就造成了数据丢失。</li>
<li>第二类丢失更新，指当两个事务同时操作同一个数据时，第一个事务将修改结果成功提交后，对第二个事务已经提交的修改结果进行了覆盖，对第二个事务造成了数据丢失。</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommitted（读未提交）"><a href="#Read-Uncommitted（读未提交）" class="headerlink" title="Read Uncommitted（读未提交）"></a>Read Uncommitted（读未提交）</h3><p>一个事务在执行过程中，既可以访问其他事务未提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据。此隔离级别可防止丢失更新。</p>
<h3 id="Read-Committed（读已提交）"><a href="#Read-Committed（读已提交）" class="headerlink" title="Read Committed（读已提交）"></a>Read Committed（读已提交）</h3><p>一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。此隔离级别可有效防止脏读。</p>
<h3 id="Repeatable-Read（可重复读取）"><a href="#Repeatable-Read（可重复读取）" class="headerlink" title="Repeatable Read（可重复读取）"></a>Repeatable Read（可重复读取）</h3><p>一个事务在执行过程中，可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。此隔离级别可有效防止不可重复读和脏读。</p>
<h3 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h3><p>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。此隔离级别可有效防止脏读、不可重复读和幻读。但这个级别可能导致大量的超时现象和锁竞争，在实际应用中很少使用。</p>
<p> 一般来说，事务的隔离级别越高，越能保证数据库的完整性和一致性，但相对来说，隔离级别越高，对并发性能的影响也越大。因此，通常将数据库的隔离级别设置为 Read  Committed，即读已提交数据，它既能防止脏读，又能有较好的并发性能。虽然这种隔离级别会导致不可重复读、幻读和第二类丢失更新这些并发问题，但可通过在应用程序中采用悲观锁和乐观锁加以控制。</p>
<h1 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h1><ul>
<li>第一范式：字段不能再分。</li>
<li>第二范式：满足第一范式的前提下，不能出现部分依赖。 消除复合主键就可以避免部分依赖。增加单列关键字。</li>
<li>第三范式：满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>在数据库中，B+树的高度一般都在2-4层，B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。</p>
<p>相同：内部都是B+树的形式，高度平衡，叶子结点存放着所有的数据。</p>
<p>不同：叶子结点存放的是否是一整行的信息。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol>
<li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li>
<li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>单一节点存储更多的元素，使得查询的IO次数更少。</li>
<li>所有查询都要查找到叶子节点，查询性能稳定。</li>
<li>所有叶子节点形成有序链表，便于范围查询。</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p>索引的目的在于提高查询效率，通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</p>
<p>磁盘IO操作成本高昂，每次查找数据时应把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。</p>
<h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分，每个数据页都通过一个双向链表来进行链接。</p>
<p>如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。</p>
<p>如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</p>
<p>由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。</p>
<p>在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。</p>
<p>对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。</p>
<p>范围查询（range query），如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页。</p>
<h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>除了聚集索引外其他索引都是辅助索引，也称非聚集索引，与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。</p>
<p>叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。</p>
<p>由于InnoDB存储引擎是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。</p>
<p>窗口函数的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="operator">&lt;</span>用于分组的列名<span class="operator">&gt;</span></span><br><span class="line">                <span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>用于排序的列名<span class="operator">&gt;</span>[<span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure>

<p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p>
<ol>
<li>专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。</li>
<li>聚合函数，如sum. avg, count, max, min等</li>
</ol>
<p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中。</p>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><ol>
<li>使用连接（JOIN）代替子查询（Sub-Queries）</li>
<li>使用联合(UNION)来代替手动创建的临时表</li>
<li>使用索引</li>
</ol>
]]></content>
      <categories>
        <category>Tech</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Network</title>
    <url>/post/af39be20.html</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul>
<li>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。</li>
<li>主要作用是传输比特流。</li>
<li>这一层的数据叫做比特。</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul>
<li>主要将从物理层接收的数据进行 MAC 地址的封装与解封装。</li>
<li>这一层的数据叫做帧。</li>
<li>在这一层工作的设备是交换机，数据通过交换机来传输。</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul>
<li>主要将从下层接收到的数据进行 IP 地址的封装与解封装。</li>
<li>这一层的数据叫做报文。</li>
<li>这一层工作的设备是路由器。</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul>
<li>定义了一些传输数据的协议和端口号。</li>
<li>主要是将从下层接收的数据进行分段传输，到达目的地址后再进行重组。 </li>
<li>常常把这一层数据叫做段。</li>
</ul>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><ul>
<li>主要在系统之间发起会话或或者接受会话请求。</li>
</ul>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><ul>
<li>主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等。</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li>主要是一些终端的应用。</li>
</ul>
<h1 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h1><ul>
<li>因特网整个 TCP&#x2F;IP 协议族。</li>
<li>从协议分层模型方面来讲，TCP&#x2F;IP 由四个层次组成：网络访问层、网络层、传输层、应用层。</li>
</ul>
<h2 id="网络访问层（Network-Access-Layer）"><a href="#网络访问层（Network-Access-Layer）" class="headerlink" title="网络访问层（Network Access Layer）"></a>网络访问层（Network Access Layer）</h2><ul>
<li>在 TCP&#x2F;IP 参考模型中并没有详细描述，只是指出主机必须使用某种协议与网络相连。</li>
</ul>
<h2 id="网络层（Internet-Layer）"><a href="#网络层（Internet-Layer）" class="headerlink" title="网络层（Internet Layer）"></a>网络层（Internet Layer）</h2><ul>
<li>整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。</li>
<li>这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同，高层需要自行对分组进行排序。</li>
<li>使用因特网协议（IP，Internet Protocol）。</li>
</ul>
<h2 id="传输层（Tramsport-Layer）"><a href="#传输层（Tramsport-Layer）" class="headerlink" title="传输层（Tramsport Layer）"></a>传输层（Tramsport Layer）</h2><ul>
<li><p>使源端和目的端机器上的对等实体可以进行会话。</p>
</li>
<li><p>在这一层定义了两个端到端的协议：</p>
<ul>
<li>传输控制协议（TCP，Transmission Control Protocol）：TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。</li>
<li>用户数据报协议（UDP，User Datagram Protocol）：UDP 是面向无连接的不可靠传输的协议，主要用于不<br>要 TCP 的排序和流量控制等功能的应用程序。</li>
</ul>
</li>
</ul>
<h2 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h2><ul>
<li>包含所有的高层协议，包括：<ul>
<li>虚拟终端协议（TELNET， TELecommunications NETwork）</li>
<li>文件传输协议（FTP，File Transfer Protocol）</li>
<li>电子邮件传输协议（SMTP，Simple Mail Transfer Protocol）</li>
<li>域名服务（DNS，Domain Name Service）</li>
<li>超文本传送协议 （HTTP，HyperText Transfer Protocol）</li>
</ul>
</li>
</ul>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><ul>
<li>源端口号（16 位）：（连同源主机 IP 地址）标识源主机的一个应用进程。</li>
<li>目的端口号（16 位）：（连同目的主机 IP 地址）标识目的主机的一个应用进程，这两个值加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。</li>
<li>顺序号（seq，32 位）：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，表示在这个报文段中的第一个数据字节的顺序号。</li>
<li>确认号 （ack，32 位）：包含发送确认的一端所期望收到的下一个顺序号，是上次已成功收到数据字节顺序号加 1 ，且只有 ACK 标志为 1 时确认序号字段才有效。</li>
<li>TCP 报头长度（4 位）：给出报头中 32bit 字的数目，指明数据从哪里开始，需要这个值是因为任选字段的长度是可变的。</li>
<li>保留位（6 位）：保留给将来使用，目前必须置为 0 。</li>
<li>控制位（control flags ，6 位）：有 6 个标志比特，它们中的多个可同时被设置为 1：<ul>
<li>URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。</li>
<li>ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。</li>
<li>PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li>
<li>RST ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。</li>
<li>SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（synchronize ）。</li>
<li>FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</li>
</ul>
</li>
<li>窗口大小（16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小，最大为 65535 字节。</li>
<li>校验和（16 位）：对整个的 TCP 报文段（包括 TCP 头部和 TCP 数据）以 16 位字进行计算所得，是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。</li>
<li>紧急指针（16位）：只有当URG标志置1时紧急指针才有效，是发送端向另一端发送紧急数据的一种方式。</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/100327002629.png" alt="100327002629"></p>
<ol>
<li>发起建立连接请求：主机A发送 <code>SYN=1，seq=x</code>。</li>
<li>确认建立连接请求：主机B发送 <code>SYN=1，ACK=1，seq=y，ack=x+1</code>。</li>
<li>建立连接：主机A发送<code>ACK=1，seq=y+1，ack=x+1</code>。</li>
</ol>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li>因为 TCP 连接是全双工的，所以进行关闭时每个方向上都要单独进行关闭。</li>
<li>半关闭：单方向的关闭</li>
<li>当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。</li>
</ul>
<p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/100327022731.jpg" alt="100327022731"></p>
<ol>
<li>主机A关闭连接请求：主机A发送 <code>FIN=1</code>。</li>
<li>主机B确认关闭连接请求：主机B发送 <code>ACK=1</code>。</li>
<li>主机B关闭连接请求：主机B发送 <code>FIN=1</code>。</li>
<li>主机A确认关闭连接请求：主机A发送 <code>ACK=1</code>。</li>
</ol>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ul>
<li>无状态的协议：客户端和服务端之间不需要建立持久的连接，服务器端不保留连接的有关信息。</li>
<li>遵循请求(Request)&#x2F;应答(Response)模型：客户端向服务端发送请求，服务端处理请求并返回适当的应答。</li>
</ul>
<h2 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h2><ol>
<li><p>地址解析</p>
<ul>
<li>解析地址中的协议名、主机名、端口、对象路径等信息。</li>
<li>其中需要 DNS 解析域名得到主机的 IP 地址。</li>
</ul>
</li>
<li><p>封装HTTP请求数据包</p>
<ul>
<li>以上数据结合本纪信息，封装数据包。</li>
</ul>
</li>
<li><p>封装 TCP 包并建立连接</p>
</li>
<li><p>客户端发送请求命令</p>
<ul>
<li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)、协议版本号，后边是 MIME 信息（包括请求修饰符、客户端信息和可能的内容）。</li>
</ul>
</li>
<li><p>服务器响应</p>
<ul>
<li>服务器接到请求后，给予相应的响应信息。</li>
<li>格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息（包括服务器信息、实体信息和可能的内容）。</li>
</ul>
</li>
<li><p>服务器关闭 TCP 连接</p>
<ul>
<li>一般情况下，一旦 Web 服务器向浏览器发送了请求数据，就要关闭 TCP 连接。</li>
<li>如果其头信息加入 <code>Connection:keep-alive</code>，TCP 连接在发送后将仍然保持打开状态，客户端可以继续通过相同的连接发送请求。</li>
<li>保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li>
</ul>
</li>
</ol>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><ul>
<li>全称：Hypertext Transfer Protocol over Secure Socket Layer。</li>
<li>是以安全为目标的 HTTP 通道，即HTTP 下加入 SSL 层，其安全基础是 SSL，所用端口号为 443。</li>
</ul>
<h2 id="获取过程"><a href="#获取过程" class="headerlink" title="获取过程"></a>获取过程</h2><ol>
<li><p>建立连接获取证书</p>
<ul>
<li>SSL 客户端通过 TCP 和服务器建立连接，在连接的协商（握手）过程中请求证书。</li>
<li>客户端发出一个消息（包括可实现的算法列表和其它一些需要的消息）给服务端，服务器端会回应一个数据包（包括这次通信所 需要的算法），然后服务端向客户端返回证书（包括服务端域名、申请证书的公司、公共秘钥）。</li>
</ul>
</li>
<li><p>证书验证</p>
<ul>
<li>客户端在收到证书后，会判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效。</li>
<li>客户端还会确保证书中列出的域名就是它正在连接的域名。</li>
</ul>
</li>
<li><p>数据加密和传输</p>
<ul>
<li>如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。</li>
<li>然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li>
</ul>
</li>
</ol>
<h1 id="CDN（Content-Delivery-Network）"><a href="#CDN（Content-Delivery-Network）" class="headerlink" title="CDN（Content Delivery Network）"></a>CDN（Content Delivery Network）</h1><ul>
<li>内容分发网络，一般包括分发服务系统、负载均衡系统和管理系统。</li>
</ul>
<h2 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h2><ul>
<li>基本的工作单元是各个 Cache 服务器，负责直接响应用户请求，将内容快速分发到用户，同时还负责内容更新，保证和源站内容的同步。</li>
<li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等，每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。</li>
<li>向上层的管理调度系统反馈各个 Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由 哪个 Cache 设备来响应用户的请求。</li>
</ul>
<h2 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h2><ul>
<li>整个 CDN 系统的中枢，负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li>
<li>使用分级实现，最基本的两极调度体系包括全局负载均衡(GSLB)和本地负载均衡(SLB)。<ul>
<li>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS 解析或者应用层重定向(Http 3XX 重定向)的方式实现。</li>
<li>SLB 主要负责节点内部的负载均衡，当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度(LVS)、七层调 度(Nginx)和链路负载调度等。</li>
</ul>
</li>
</ul>
<h2 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h2><ul>
<li>分为运营管理和网络管理子系统。</li>
<li>实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理。</li>
<li>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、 交付工作。包括用户管理、产品管理、计费管理、统计分析等。</li>
</ul>
<h2 id="POST和GET区别"><a href="#POST和GET区别" class="headerlink" title="POST和GET区别"></a>POST和GET区别</h2><p>POST和GET是HTTP请求的两种方式，都可实现将数据从浏览器向服务器发送带参数的请求。</p>
<p>HTTP请求底层协议都是TCP&#x2F;IP，所以两者没有本质的区别。</p>
<ul>
<li>GET - 从指定的资源请求数据。</li>
<li>POST - 向指定的资源提交要被处理的数据</li>
</ul>
<ol>
<li>GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密）</li>
<li>GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）</li>
<li>GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有</li>
<li>GET可以被保存为书签，POST不可以。</li>
<li>GET能被缓存，POST不能</li>
<li>GET只允许ASCII字符，POST没有限制</li>
<li>GET会保存再浏览器历史记录中，POST不会。</li>
</ol>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Interview Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>对称的二叉树</title>
    <url>/post/150c34dd.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>广度优先搜索</li>
<li>递归</li>
</ul>
<span id="more"></span>

<h2 id="镜像判断"><a href="#镜像判断" class="headerlink" title="镜像判断"></a>镜像判断</h2><ul>
<li>当前节点的左右节点的值相同</li>
<li>当前节点的左子树与右子树镜像对称</li>
</ul>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h3><ul>
<li>左右节点均为 null，返回 true</li>
<li>左右节点仅有一个为 null，返回 false</li>
</ul>
<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><ol>
<li>从根节点出发，使用两个指针分别指向左右节点</li>
<li>递归判断左指针的左节点与右指针的右节点以及左指针的右节点与右指针的左节点的对称性</li>
</ol>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == p &amp;&amp; <span class="literal">null</span> == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == p || <span class="literal">null</span> == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p.val == q.val &amp;&amp; bfs(p.left, q.right) &amp;&amp; bfs(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><ul>
<li><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树 - 力扣（LeetCode）</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>两整数之和</title>
    <url>/post/abe383d1.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>位运算</li>
</ul>
<span id="more"></span>

<h3 id="亦或运算"><a href="#亦或运算" class="headerlink" title="亦或运算"></a>亦或运算</h3><ul>
<li>计算当前位的无进位加法结果</li>
<li><code>a ^ b</code></li>
</ul>
<h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><ul>
<li>计算来自前一位的进位结果</li>
<li><code>(a &amp; b) &lt;&lt; 1</code></li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>两者亦或运算即为加法结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSum(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Bit Operation</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/post/fd4c32db.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>深度优先搜索</li>
</ul>
<span id="more"></span>

<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ol>
<li>当前节点为空，说明搜到底部，搜索结束。</li>
<li>当前节点等于目标节点，说明搜到目标节点，返回当前节点。</li>
</ol>
<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><ol>
<li>分别搜索当前节点的左右子树。</li>
<li>如果某一子树为空，则说明目标节点均在另一棵子树上。</li>
<li>否则目标节点分别在两子树上。</li>
</ol>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchCommonAncestor</span><span class="params">(TreeNode node, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == p || node == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> searchCommonAncestor(node.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> searchCommonAncestor(node.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == left) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><ul>
<li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树中的搜索</title>
    <url>/post/b3250fa1.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>递归</li>
<li>深度优先搜索</li>
</ul>
<span id="more"></span>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul>
<li>左子树所有节点的元素值均小于根的元素值</li>
<li>右子树所有节点的元素值均大于根的元素值</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(node.val &lt; val ? node.right : node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>亲密字符串</title>
    <url>/post/2feb7301.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>模拟</li>
</ul>
<span id="more"></span>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>当 s 与 goal 长度或词频不同，必然不为亲密字符</li>
<li>当 s 与 goal 不同的字符数量为 2 或 s 与 goal 不同的字符数量为 0，且 s 中有出现数量超过 2 的字符时，必然为亲密字符</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">buddyStrings</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = goal.length();</span><br><span class="line">    <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] cnt1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>], cnt2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>, b = goal.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cnt1[a]++; cnt2[b]++;</span><br><span class="line">        <span class="comment">// 不同字符数量统计</span></span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 词频不同必然不为亲密字符</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1[i] != cnt2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 词频相同，且同时出现数量超过2的字符，必然为亲密字符</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">return</span> <span class="variable">sum</span> <span class="operator">=</span>= <span class="number">2</span> || (sum == <span class="number">0</span> &amp;&amp; flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/buddy-strings/">859. 亲密字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/post/b724efa.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>栈</li>
</ul>
<span id="more"></span>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>先进后出，实现转置</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(head.val);</span><br><span class="line">    head = head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> stack.size();</span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[sum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">    res[i] = stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>从英文中重建数字</title>
    <url>/post/2cdd2c09.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>词频统计</li>
<li>哈希</li>
</ul>
<span id="more"></span>

<h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><ul>
<li>统计每个字母分别在哪些数字中出现：</li>
</ul>
<table>
<thead>
<tr>
<th>字母</th>
<th>数字</th>
</tr>
</thead>
<tbody><tr>
<td>e</td>
<td>0 1 3 5 7 8 9</td>
</tr>
<tr>
<td>f</td>
<td>4 5</td>
</tr>
<tr>
<td>g</td>
<td>8</td>
</tr>
<tr>
<td>h</td>
<td>3 8</td>
</tr>
<tr>
<td>i</td>
<td>5 6 8 9</td>
</tr>
<tr>
<td>n</td>
<td>1 7 9</td>
</tr>
<tr>
<td>o</td>
<td>0 1 2 4</td>
</tr>
<tr>
<td>r</td>
<td>0 3 4</td>
</tr>
<tr>
<td>s</td>
<td>6 7</td>
</tr>
<tr>
<td>t</td>
<td>2 3 8</td>
</tr>
<tr>
<td>u</td>
<td>4</td>
</tr>
<tr>
<td>v</td>
<td>5 7</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>x</td>
<td>6</td>
</tr>
<tr>
<td>z</td>
<td>0</td>
</tr>
</tbody></table>
<ul>
<li>第一轮确定 0、2、4、6、8</li>
<li>第二轮确定 3、5、7</li>
<li>第三轮确定 1、9</li>
<li>n 在 9 中出现了 2 次，e 在 3 中出现了 3 次</li>
</ul>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><ul>
<li>根据词频统计结果依次进行哈希查找</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="词频统计-1"><a href="#词频统计-1" class="headerlink" title="词频统计"></a>词频统计</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    cnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] digits = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// Z</span></span><br><span class="line">digits[<span class="number">0</span>] = cnt[<span class="number">25</span>];</span><br><span class="line">cnt[<span class="number">14</span>] -= cnt[<span class="number">25</span>];</span><br><span class="line"><span class="comment">// W</span></span><br><span class="line">digits[<span class="number">2</span>] = cnt[<span class="number">22</span>];</span><br><span class="line">cnt[<span class="number">14</span>] -= cnt[<span class="number">22</span>];</span><br><span class="line"><span class="comment">// U</span></span><br><span class="line">digits[<span class="number">4</span>] = cnt[<span class="number">20</span>];</span><br><span class="line">cnt[<span class="number">5</span>] -= cnt[<span class="number">20</span>];</span><br><span class="line">cnt[<span class="number">14</span>] -= cnt[<span class="number">20</span>];</span><br><span class="line"><span class="comment">// X</span></span><br><span class="line">digits[<span class="number">6</span>] = cnt[<span class="number">23</span>];</span><br><span class="line">cnt[<span class="number">18</span>] -= cnt[<span class="number">23</span>];</span><br><span class="line">cnt[<span class="number">8</span>] -= cnt[<span class="number">23</span>];</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">digits[<span class="number">8</span>] = cnt[<span class="number">6</span>];</span><br><span class="line">cnt[<span class="number">7</span>] -= cnt[<span class="number">6</span>];</span><br><span class="line">cnt[<span class="number">8</span>] -= cnt[<span class="number">6</span>];</span><br><span class="line"><span class="comment">// H</span></span><br><span class="line">digits[<span class="number">3</span>] = cnt[<span class="number">7</span>];</span><br><span class="line"><span class="comment">// F</span></span><br><span class="line">digits[<span class="number">5</span>] = cnt[<span class="number">5</span>];</span><br><span class="line">cnt[<span class="number">8</span>] -= cnt[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// S</span></span><br><span class="line">digits[<span class="number">7</span>] = cnt[<span class="number">18</span>];</span><br><span class="line"><span class="comment">// O</span></span><br><span class="line">digits[<span class="number">1</span>] = cnt[<span class="number">14</span>];</span><br><span class="line"><span class="comment">// I</span></span><br><span class="line">digits[<span class="number">9</span>] = cnt[<span class="number">8</span>];</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">423. 从英文中重建数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Word Frequency Statistics</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>分糖果</title>
    <url>/post/82a9a2c2.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>贪心</li>
</ul>
<span id="more"></span>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul>
<li>能拿到的种类数量不会超过糖果总数 m 的一半</li>
<li>能拿到的种类数量不会超过糖果总种类数量，n</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCandies</span><span class="params">(<span class="type">int</span>[] candyType)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> candyType.length;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer candy: candyType) &#123;</span><br><span class="line">        set.add(candy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(n / <span class="number">2</span>, set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/distribute-candies/">575. 分糖果 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中的节点</title>
    <url>/post/7bf1bf61.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>链表</li>
</ul>
<span id="more"></span>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>用下一个节点直接替换当前节点</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">    node.val = next.val;</span><br><span class="line">    node.next = next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/post/2e394548.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>数组</li>
</ul>
<span id="more"></span>

<h3 id="进位检查"><a href="#进位检查" class="headerlink" title="进位检查"></a>进位检查</h3><ul>
<li>carry初始为1</li>
<li>逆序遍历</li>
<li>加法操作</li>
<li>记录每位加法之后的进位情况</li>
<li>结果取余</li>
</ul>
<h3 id="首位进位"><a href="#首位进位" class="headerlink" title="首位进位"></a>首位进位</h3><ul>
<li>当首位出现进位情况时，构造一个长度多1的新数组</li>
<li>新数组首位置1</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="进位检查-1"><a href="#进位检查-1" class="headerlink" title="进位检查"></a>进位检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    digits[i] = digits[i] + carry;</span><br><span class="line">    carry = digits[i] == <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    digits[i] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="首位检查"><a href="#首位检查" class="headerlink" title="首位检查"></a>首位检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">    digits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>可怜的小猪</title>
    <url>/post/7012e621.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>数学：信息论</li>
</ul>
<span id="more"></span>

<h3 id="数学：信息论"><a href="#数学：信息论" class="headerlink" title="数学：信息论"></a>数学：信息论</h3><ul>
<li><p>表达 n 桶水状态所需的位数：$\log_2 n$</p>
</li>
<li><p>一个猪实验 k 次的状态所实现的位数：$\log_2 (k+1)$</p>
</li>
<li><p>所需猪的最小数量 m：</p>
<p>$$<br>m \geq \frac{\log_2 n}{\log_2 (k+1)}<br>$$</p>
</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poorPigs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> t / d;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>) Math.ceil(Math.log(n) / Math.log(k + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/poor-pigs/">458. 可怜的小猪 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个排序的链表</title>
    <url>/post/faa1cd64.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>递归</li>
</ul>
<span id="more"></span>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>两个链表有一个为空，结束递归。</p>
<h3 id="递归路径"><a href="#递归路径" class="headerlink" title="递归路径"></a>递归路径</h3><ol>
<li>选择两个链表的头节点中值较小的作为当前节点</li>
<li>合并该链表的下一个节点与另一个链表，作为下一个节点</li>
<li>返回当前节点</li>
</ol>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = merge(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = merge(l2.next, l1);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><ul>
<li><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/he-bing-liang-ge-pai-xu-de-lian-biao-by-g3z6g/">合并两个排序的链表 - 合并两个排序的链表 - 力扣（LeetCode）</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>将数据流变为多个不相交区间</title>
    <url>/post/757a9357.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>有序映射</li>
</ul>
<span id="more"></span>

<h3 id="区间集合"><a href="#区间集合" class="headerlink" title="区间集合"></a>区间集合</h3><ol>
<li>存在区间[l, r]，满足l&lt;&#x3D; val&lt;&#x3D;r，无变化；</li>
<li>存在区间[l, r]，满足val&#x3D;r+1，该区间变为[l, r+1]；</li>
<li>存在区间[l, r]，满足val&#x3D;l-1，该区间变为[l-1, r]；</li>
<li>存在区间[l0, r0]、[l1, r1]，满足val&#x3D;r0+1&#x3D;l1-1，两区间合并为[l0, r1]；</li>
<li>以上均不满足，val单独成立新区间[val, val]。</li>
</ol>
<h3 id="有序映射"><a href="#有序映射" class="headerlink" title="有序映射"></a>有序映射</h3><ul>
<li>键存放左区间，值存放右区间</li>
<li>支持查询“最大的比某个元素小的键“与“最小的比某个元素大的键”</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到l1最小且满足l1&gt;val的区间</span></span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; interval1 = intervals.ceilingEntry(val + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 找到l0最大且满足l0&lt;=val的区间</span></span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; interval0 = intervals.floorEntry(val);</span><br></pre></td></tr></table></figure>

<h3 id="情况讨论"><a href="#情况讨论" class="headerlink" title="情况讨论"></a>情况讨论</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (interval0 != <span class="literal">null</span> &amp;&amp; interval0.getKey() &lt;= val &amp;&amp; val &lt;= interval0.getValue()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">leftAside</span> <span class="operator">=</span> interval0 != <span class="literal">null</span> &amp;&amp; interval0.getValue() + <span class="number">1</span> == val;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rightAside</span> <span class="operator">=</span> interval1 != <span class="literal">null</span> &amp;&amp; interval1.getKey() - <span class="number">1</span> == val;</span><br><span class="line">    <span class="comment">// 情况四</span></span><br><span class="line">    <span class="keyword">if</span> (leftAside &amp;&amp; rightAside) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> interval0.getKey(), right = interval1.getValue();</span><br><span class="line">        intervals.remove(interval0.getKey());</span><br><span class="line">        intervals.remove(interval1.getKey());</span><br><span class="line">        intervals.put(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况二</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (leftAside) &#123;</span><br><span class="line">        intervals.put(interval0.getKey(), val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况三</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rightAside) &#123;</span><br><span class="line">        intervals.put(val, interval1.getValue());</span><br><span class="line">        intervals.remove(interval1.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况五</span></span><br><span class="line">        intervals.put(val, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/">352. 将数据流变为多个不相交区间 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/post/57ece9e2.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>Fisher-Yates 洗牌算法</li>
</ul>
<span id="more"></span>

<h3 id="Fisher-Yates-洗牌算法"><a href="#Fisher-Yates-洗牌算法" class="headerlink" title="Fisher-Yates 洗牌算法"></a>Fisher-Yates 洗牌算法</h3><ul>
<li>对于下标 x 而言，从 [x, n - 1] 中随机出一个位置与 x 进行值交换，当所有位置都进行这样的处理后，便得到一个公平的洗牌方案</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="Fisher-Yates-洗牌算法-1"><a href="#Fisher-Yates-洗牌算法-1" class="headerlink" title="Fisher-Yates 洗牌算法"></a>Fisher-Yates 洗牌算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shuffle() &#123;</span><br><span class="line">    <span class="type">int</span>[] res = nums.clone();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> res.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + random.nextInt(n - i);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> res[i];</span><br><span class="line">        res[i] = res[j];</span><br><span class="line">        res[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Shuffle</tag>
      </tags>
  </entry>
  <entry>
    <title>在LR字符串中交换相邻字符</title>
    <url>/post/ed90568f.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>双指针</li>
</ul>
<span id="more"></span>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li>两种交换可视为 L 字符可一直左移，直到碰到 R 字符；R 字符可一直右移，直到碰到 L 字符</li>
<li>问题转化为两字符的相对位置是否一致</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="两指针"><a href="#两指针" class="headerlink" title="两指针"></a>两指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针同时遍历</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">    <span class="comment">// 找到下一个不为 X 的字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; start.charAt(i) == CHAR_X) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; end.charAt(j) == CHAR_X) &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 如果两个字符不相等，说明顺序不一致</span></span><br><span class="line">        <span class="keyword">if</span> (start.charAt(i) != end.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> start.charAt(i);</span><br><span class="line">        <span class="comment">// 字符为 L，i 应小于 j</span></span><br><span class="line">        <span class="keyword">if</span> (ch == CHAR_L &amp;&amp; j &gt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符为 R，i 应大于 j</span></span><br><span class="line">        <span class="keyword">if</span> (ch == CHAR_R &amp;&amp; j &lt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有剩余的非 X 字符，说明顺序不一致</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start.charAt(i) != CHAR_X) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (end.charAt(j) != CHAR_X) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Double Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>按照频率将数组升序排序</title>
    <url>/post/dfe107c2.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>哈希</li>
<li>排序</li>
</ul>
<span id="more"></span>

<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><ul>
<li>哈希存储数值出现的频率</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>Map 本身无法自定义排序，需要将 Map.Entry 转换为 List 进行排序处理</li>
<li>根据数值的频率升序排列，如果多个值的频率相同，则按照数值大小降序排列</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">    count.put(num, count.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(count.entrySet());</span><br><span class="line">entries.sort((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (o2.getValue().equals(o1.getValue())) &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getKey() - o1.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1.getValue() - o2.getValue();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/sort-array-by-increasing-frequency/">1636. 按照频率将数组升序排序 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/post/cc713db.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>动态规划</li>
<li>记忆化搜索</li>
</ul>
<span id="more"></span>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>$$<br>F(n) &#x3D; F(n-1) + F(n-2)<br>$$</p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><ul>
<li>存储计算值，供后续计算使用，避免重复计算</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若缓存中已有计算值，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cache[n] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并缓存</span></span><br><span class="line">    cache[n] = (calculate(n - <span class="number">1</span>) + calculate(n - <span class="number">2</span>)) % MOD;</span><br><span class="line">    <span class="keyword">return</span> cache[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="记忆化搜索-1"><a href="#记忆化搜索-1" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Memory Search</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索二维矩阵 II</title>
    <url>/post/870af79c.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>二分查找</li>
</ul>
<span id="more"></span>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li>无法保证每行的第一个整数大于前一行的最后一个整数</li>
<li>只能先遍历行，然后再对行进行二分查找。</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] col : matrix) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (col[mid] &lt;= target) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (col[l] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>提莫攻击</title>
    <url>/post/d28cdc4f.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>模拟</li>
</ul>
<span id="more"></span>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>模拟中毒时间区间的合并</li>
<li>若下一个区间的左边界大于上一个区间的右边界，则统计上一个区间的范围</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> time: timeSeries) &#123;</span><br><span class="line">    <span class="keyword">if</span> (time &gt; r) &#123;</span><br><span class="line">        cnt += (r - l);</span><br><span class="line">        l = time;</span><br><span class="line">    &#125;</span><br><span class="line">    r = time + duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. 提莫攻击 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>最小操作次数使数组元素相等</title>
    <url>/post/c4d94f41.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>数学</li>
</ul>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>使 n−1 个元素增加 1，等价于使1 个元素减少 1</p>
<span id="more"></span>

<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">minNum</span> <span class="operator">=</span> Arrays.stream(nums).min().getAsInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">  res += num - minNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">453. 最小操作次数使数组元素相等 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/post/cd96fb91.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>字符串</li>
</ul>
<span id="more"></span>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>模拟 replace 过程，按位比较，append 进 StringBuilder 中</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sb.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/post/6e519af2.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>二分查找</li>
</ul>
<span id="more"></span>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li>序列变为分段有序，第一段序列的数值均大于 nums[0]，第二段则反之</li>
<li>当旋转点使得相同的数值发生分裂，则上述特性失效，故需要预处理，左移右边界</li>
<li>特殊考虑旋转了 0 个数值的情况，即本身有序</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除末尾与首位相等的情况</span></span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; numbers[r] == numbers[<span class="number">0</span>]) &#123;</span><br><span class="line">    r--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (numbers[mid] &lt; numbers[<span class="number">0</span>]) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排除本身有序的情况</span></span><br><span class="line"><span class="keyword">return</span> Math.min(numbers[l], numbers[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组中的单一元素</title>
    <url>/post/fe62bbc2.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>二分查找</li>
</ul>
<span id="more"></span>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li>判断当前位置的数是否唯一</li>
<li>若当前位置为奇数，则比较当前位置和前一位置的数是否相等，反之亦然</li>
<li>若相等则唯一数在右侧（含），反之在左侧（不含）</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchSingle</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[idx] == nums[idx - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[idx] == nums[idx + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的完全平方数</title>
    <url>/post/9622dea8.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>二分查找</li>
</ul>
<span id="more"></span>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li>若正整数 x 满足$x \times x &#x3D; num$，则 x 一定满足$1 \le x \le num$</li>
<li>除 1 外的num，一定满足$ x \le num &#x2F; 2$</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num ==  <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> num / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &lt;= num) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l * l == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>检查二进制字符串字段</title>
    <url>/post/d8f51433.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>方法一：模拟</li>
<li>方法二：字符串</li>
</ul>
<span id="more"></span>

<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><ul>
<li>没有前导零，遍历到出现 0 后，检查后续是否有 1出现</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>由于没有先导零，则 0 后必不能出现 1，直接判断是否包含子串 01 即可</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历直到出现 0，当前连续 1 字段结束</span></span><br><span class="line"><span class="keyword">while</span> (idx &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(idx) == CHAR_0) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若再出现字段 1，则不符合要求</span></span><br><span class="line"><span class="keyword">while</span> (idx &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(idx) == CHAR_1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> !s.contains(<span class="string">&quot;01&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/">1784. 检查二进制字符串字段 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Simulation</tag>
        <tag>Str</tag>
      </tags>
  </entry>
  <entry>
    <title>求众数 II</title>
    <url>/post/be1b1658.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>摩尔投票法</li>
</ul>
<span id="more"></span>

<h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><ul>
<li>抵消阶段：两个不同投票进行对坑，并且同时抵消掉各一张票，如果两个投票相同，则累加可抵消的次数</li>
<li>计数阶段：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定。</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="抵消阶段"><a href="#抵消阶段" class="headerlink" title="抵消阶段"></a>抵消阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">candidate1</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">candidate2</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">vote1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">vote2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidate1 == num) &#123;</span><br><span class="line">        vote1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidate2 == num) &#123;</span><br><span class="line">        vote2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vote1 == <span class="number">0</span>) &#123;</span><br><span class="line">        candidate1 = num;</span><br><span class="line">        vote1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vote2 == <span class="number">0</span>) &#123;</span><br><span class="line">        candidate2 = num;</span><br><span class="line">        vote2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        vote1--;</span><br><span class="line">        vote2--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数阶段"><a href="#计数阶段" class="headerlink" title="计数阶段"></a>计数阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vote1 = <span class="number">0</span>;</span><br><span class="line">vote2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidate1 == num) &#123;</span><br><span class="line">        vote1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (candidate2 == num) &#123;</span><br><span class="line">        vote2++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Boyer–Moore majority vote algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>消失的两个数字</title>
    <url>/post/788ed63c.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>数学</li>
</ul>
<span id="more"></span>

<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ol>
<li>消失的两数之和 &#x3D; n~1 求和减去当前数组求和</li>
<li>两数不相等，则必然位于两数之和的均值的两侧，可将问题转化为求消失的一个数字</li>
</ol>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length + <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求消失的两数之和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sumTwo</span> <span class="operator">=</span> n * (n + <span class="number">1</span>) / <span class="number">2</span> - sum;</span><br><span class="line"><span class="type">int</span> <span class="variable">mean</span> <span class="operator">=</span> sumTwo / <span class="number">2</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 求消失的两数中较小的数，将问题转化为求消失的一个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= mean) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> mean * (mean + <span class="number">1</span>) / <span class="number">2</span> - sum;</span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> sumTwo - x1;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/missing-two-lcci/">面试题 17.19. 消失的两个数字 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>灯泡开关</title>
    <url>/post/9c3f2398.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>数学</li>
</ul>
<span id="more"></span>

<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul>
<li>对于第 k 个灯泡，它被切换的次数恰好就是 k 的约数个数；当 k 的约数个数为奇数时，第 k 个灯泡亮</li>
<li>若某个数 x 为 k 的约数，则$\frac{k}{x}$亦为 k 的约数，即约数必然成对出现；只有当 x 为完全平方数时，约数个数为奇数</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bulbSwitch</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.sqrt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>猜数字游戏</title>
    <url>/post/96fc0eef.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>模拟</li>
</ul>
<span id="more"></span>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>按位比较，若相同则公牛数量增加，若不同则分别统计词频</li>
<li>[0, 9] 数字的词频的最小值总和，为母牛数量</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="按位比较"><a href="#按位比较" class="headerlink" title="按位比较"></a>按位比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="type">char</span> <span class="variable">chS</span> <span class="operator">=</span> secret.charAt(i);</span><br><span class="line">  <span class="type">char</span> <span class="variable">chG</span> <span class="operator">=</span> guess.charAt(i);</span><br><span class="line">  <span class="keyword">if</span> (chS == chG) &#123;</span><br><span class="line">  	bull++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  	cntS[chS - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">  	cntG[chG - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小值总和"><a href="#最小值总和" class="headerlink" title="最小值总和"></a>最小值总和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    cow += Math.min(cntS[i], cntG[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/bulls-and-cows/">猜数字游戏</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/post/f88f910f.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>栈</li>
</ul>
<span id="more"></span>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>一个栈作为输入栈，当 appendTail 操作时 push 数据</li>
<li>一个栈作为输出栈，当 deleteHead 操作时，若该栈为空，则将输入栈的所有数据出栈并入输出栈，此时该栈的出栈顺序满足 deleteHead 要求</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    inStack.push(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 outStack 为空，将 inStack 中的元素全部压入 outStack</span></span><br><span class="line">    <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 outStack 仍为空，说明 inStack 也为空，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>相似度为 K 的字符串</title>
    <url>/post/83e18ceb.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>广度优先搜索</li>
</ul>
<span id="more"></span>

<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><ul>
<li><p>两字符串为字母异位词，保证必存在交换方案</p>
</li>
<li><p>给定的字符串的长度范围为 [1,20]，且只包含 6 种不同的字符，可以枚举所有可能的交换方案</p>
</li>
<li><p>搜索时通过剪枝提高效率</p>
</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Pair&lt;String, Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(s1, <span class="number">0</span>));</span><br><span class="line">visited.add(s1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    Pair&lt;String, Integer&gt; pair = queue.poll();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> pair.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> pair.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur.equals(s2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 剪枝，找到第一个不同的字符</span></span><br><span class="line">    <span class="keyword">while</span> (cur.charAt(idx) == s2.charAt(idx)) &#123;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx + <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝，找到第一个不同的字符</span></span><br><span class="line">        <span class="keyword">if</span> (cur.charAt(i) == s2.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到与 s2[idx] 相同的字符，交换</span></span><br><span class="line">        <span class="keyword">if</span> (cur.charAt(i) == s2.charAt(idx)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> swap(cur, idx, i);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(next, step + <span class="number">1</span>));</span><br><span class="line">                visited.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/k-similar-strings/">854. 相似度为 K 的字符串 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>矩形面积</title>
    <url>/post/4121e703.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>容斥原理</li>
</ul>
<span id="more"></span>

<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><ul>
<li>两矩阵在水平和竖直方向上的交集投影线段构成交集面积的长和宽</li>
<li>交集投影线段均大于0时，才说明有交集面积</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">overlapWidth</span> <span class="operator">=</span> Math.min(ax2, bx2) - Math.max(ax1, bx1);</span><br><span class="line"><span class="type">int</span> <span class="variable">overlapHeight</span> <span class="operator">=</span> Math.min(ay2, by2) - Math.max(ay1, by1);</span><br><span class="line"><span class="type">int</span> <span class="variable">overlapArea</span> <span class="operator">=</span> Math.max(overlapWidth, <span class="number">0</span>) * Math.max(overlapHeight, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/rectangle-area/">223. 矩形面积 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的幸运数</title>
    <url>/post/f5f54f75.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>模拟</li>
</ul>
<span id="more"></span>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>幸运数应满足：在同一行的所有元素中最小；在同一列的所有元素中最大</li>
<li>预处理每行每列的最值</li>
<li>遍历比较当前数是否等于所在行列的最值</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="预处理最值"><a href="#预处理最值" class="headerlink" title="预处理最值"></a>预处理最值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] minRow = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="type">int</span>[] maxCol = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">Arrays.fill(minRow, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">        minRow[i] = Math.min(minRow[i], num);</span><br><span class="line">        maxCol[j] = Math.max(maxCol[j], num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历比较"><a href="#遍历比较" class="headerlink" title="遍历比较"></a>遍历比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">        <span class="keyword">if</span> (num == minRow[i] &amp;&amp; num == maxCol[j]) &#123;</span><br><span class="line">            res.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/">1380. 矩阵中的幸运数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的路径</title>
    <url>/post/386d387d.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>深度优先搜索</li>
</ul>
<span id="more"></span>

<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><ul>
<li>任意位置均可作为搜索的起点</li>
</ul>
<h3 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h3><ul>
<li>数组越界</li>
<li>当前位置已访问</li>
<li>当前字符与目标字符不匹配</li>
</ul>
<h3 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h3><ul>
<li>当前递归次数等于目标字符串长度</li>
</ul>
<h3 id="搜索步骤"><a href="#搜索步骤" class="headerlink" title="搜索步骤"></a>搜索步骤</h3><ul>
<li>标记当前位置为已访问</li>
<li>递归次数自增</li>
<li>向当前位置的四个方向继续搜索</li>
<li>回溯，标记当前位置为未访问</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果数组越界、当前位置已访问或当前字符与目标字符不匹配，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j] || board[i][j] != word.charAt(idx)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归次数等于目标字符串长度，说明已经匹配到最后一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (idx == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前位置已访问</span></span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    idx++;</span><br><span class="line">    <span class="comment">// 向当前位置的四个方向继续搜索，只要有一个方向能匹配到，就返回 true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(i + <span class="number">1</span>, j, idx) || dfs(i - <span class="number">1</span>, j, idx) || dfs(i, j + <span class="number">1</span>, idx) || dfs(i, j - <span class="number">1</span>, idx);</span><br><span class="line">    <span class="comment">// 回溯，将当前位置标记为未访问</span></span><br><span class="line">    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>超级洗衣机</title>
    <url>/post/3132132e.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>贪心</li>
<li>计算经过当前洗衣机左右两侧洗衣机需要调整次数的最大“流量”</li>
</ul>
<span id="more"></span>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul>
<li>最大需要调整次数的位置i达到平衡时，其他需要调整的位置一定也达到平衡</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num: machines) &#123;</span><br><span class="line">    num -= avg; <span class="comment">// i位置需要调整的次数</span></span><br><span class="line">    sum += num; <span class="comment">// 位置0到i需要调整的总次数</span></span><br><span class="line"></span><br><span class="line">    res = Math.max(res, Math.max(Math.abs(sum), num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Math.abs(sum)</code>，可能为负数，缺少时需要增加的情况，故为绝对值</li>
<li><code>num</code>，可能为负数，但缺少时可以是多个位置同时向此位置增加，故不能加绝对值；仅需要考虑该值特别大时的情况（num&gt;sum）</li>
</ul>
<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/super-washing-machines/">517. 超级洗衣机 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>第 k 个数</title>
    <url>/post/2a9a6beb.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>多路并归</li>
</ul>
<span id="more"></span>

<h2 id="多路并归"><a href="#多路并归" class="headerlink" title="多路并归"></a>多路并归</h2><ul>
<li>后续数值均基于已有数值乘以 3、5 或 7 而来</li>
<li>所有数值均可归为 $arr[idx] \times 系数（即3、5、7）$ 得来的三个序列，使用三个指针分别指向上述序列</li>
<li>生成新的数值时，判断所属序列（不唯一），其对应指针右移</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="多路并归-1"><a href="#多路并归-1" class="headerlink" title="多路并归"></a>多路并归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">cache[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 三序列指针</span></span><br><span class="line"><span class="type">int</span> <span class="variable">idx3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">idx5</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">idx7</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="comment">// 三序列最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> cache[idx3] * <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num5</span> <span class="operator">=</span> cache[idx5] * <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num7</span> <span class="operator">=</span> cache[idx7] * <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    cache[i] = Math.min(Math.min(num3, num5), num7);</span><br><span class="line">    <span class="comment">// 三序列指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (cache[i] == num3) &#123;</span><br><span class="line">        idx3++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache[i] == num5) &#123;</span><br><span class="line">        idx5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache[i] == num7) &#123;</span><br><span class="line">        idx7++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>K-May Merge</tag>
      </tags>
  </entry>
  <entry>
    <title>路径交叉</title>
    <url>/post/46d62dcd.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>数学归纳</li>
</ul>
<span id="more"></span>

<h3 id="数学归纳"><a href="#数学归纳" class="headerlink" title="数学归纳"></a>数学归纳</h3><h4 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h4><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/cross_1.png" alt="cross_1"></p>
<ul>
<li>第 i 次移动和第 i−3 次移动（包含端点）交叉的情况</li>
<li>第 i−1 次移动距离小于等于第 i−3 次移动距离</li>
<li>第 i 次移动距离大于等于第 i−2 次移动距离</li>
</ul>
<h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h4><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/cross_2.png" alt="cross_2"></p>
<ul>
<li>第 4 次移动距离等于第 2 次移动距离。</li>
<li>第 5 次移动距离大于等于第 3 次移动距离减第 1 次移动距离的差</li>
</ul>
<h4 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h4><p><img src="https://chrisgray.oss-cn-beijing.aliyuncs.com/Imageshack/cross_3.png" alt="cross_3"></p>
<ul>
<li><p>第 i−1 次移动距离大于等于第 i−3 次移动距离</p>
</li>
<li><p>第 i−2 次移动距离大于等于第 i−4 次移动距离</p>
</li>
<li><p>第 i 次移动距离大于等于第 i−2 次移动距离减第 i−4 次移动距离的差</p>
</li>
<li><p>第 i−1 次移动距离大于等于第 i−3 次移动距离减第 i−5 次移动距离的差</p>
</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="数学归纳-1"><a href="#数学归纳-1" class="headerlink" title="数学归纳"></a>数学归纳</h3><h4 id="第一种情况-1"><a href="#第一种情况-1" class="headerlink" title="第一种情况"></a>第一种情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一类情况</span></span><br><span class="line"><span class="keyword">if</span> (distance[i - <span class="number">1</span>] &lt;= distance[i - <span class="number">3</span>]</span><br><span class="line">        &amp;&amp; distance[i] &gt;= distance[i - <span class="number">2</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种情况-1"><a href="#第二种情况-1" class="headerlink" title="第二种情况"></a>第二种情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二类情况</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span></span><br><span class="line">        &amp;&amp; distance[i - <span class="number">2</span>] &gt;= distance[i - <span class="number">4</span>]</span><br><span class="line">        &amp;&amp; distance[i - <span class="number">1</span>] == distance[i - <span class="number">3</span>]</span><br><span class="line">        &amp;&amp; distance[i] &gt;= distance[i - <span class="number">2</span>] - distance[i - <span class="number">4</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三种情况-1"><a href="#第三种情况-1" class="headerlink" title="第三种情况"></a>第三种情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三类情况</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">4</span></span><br><span class="line">        &amp;&amp; distance[i - <span class="number">1</span>] &lt;= distance[i - <span class="number">3</span>]</span><br><span class="line">        &amp;&amp; distance[i - <span class="number">2</span>] &gt;= distance[i - <span class="number">4</span>]</span><br><span class="line">        &amp;&amp; distance[i] &gt;= distance[i - <span class="number">2</span>] - distance[i - <span class="number">4</span>]</span><br><span class="line">        &amp;&amp; distance[i - <span class="number">1</span>] &gt;= distance[i - <span class="number">3</span>] - distance[i - <span class="number">5</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/self-crossing/">335. 路径交叉 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Mathematical Induction</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和 III</title>
    <url>/post/41308982.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>深度优先搜索</li>
<li>前缀和</li>
</ul>
<span id="more"></span>

<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul>
<li>穷举所有节点，统计以当前节点为起始节点的符合要求的路径数量</li>
<li>分别统计左右节点情况，返回数量</li>
</ul>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><ul>
<li>前缀和：由根节点到当前节点的路径上所有节点的和</li>
<li>先序遍历，记录下根节点到当前节点的路径上除当前节点以外所有节点的前缀和</li>
<li>统计在已保存的路径前缀和中是否存在当前节点到根节点的前缀和减去节点pi到根结点的前缀和为targetSum的路径</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算当前节点</span></span><br><span class="line">dfs(root, targetSum);</span><br><span class="line"><span class="comment">// 穷举左右节点</span></span><br><span class="line">pathSum(root.left, targetSum);</span><br><span class="line">pathSum(root.right, targetSum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root.val;</span><br><span class="line">  <span class="keyword">if</span> (val == targetSum) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计左右节点</span></span><br><span class="line">  dfs(root.left, targetSum - val);</span><br><span class="line">  dfs(root.right, targetSum - val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和-1"><a href="#前缀和-1" class="headerlink" title="前缀和"></a>前缀和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> cur, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    cur += root.val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计符合的前缀和</span></span><br><span class="line">    sum += prefix.getOrDefault(cur - targetSum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前节点的前缀和</span></span><br><span class="line">    prefix.put(cur, prefix.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    dfs(root.left, cur, targetSum);</span><br><span class="line">    dfs(root.right, cur, targetSum);</span><br><span class="line">    <span class="comment">// 回溯时移除当前节点前缀和</span></span><br><span class="line">    prefix.put(cur, prefix.getOrDefault(cur, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Prefix</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/post/97fc4ab0.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>递归</li>
</ul>
<span id="more"></span>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ol>
<li>前序遍历的第一个节点为根节点</li>
<li>根据根节点将中序遍历划分为 [左子树｜根节点｜右子树]</li>
<li>根据中序遍历中左右子树的节点数将前序遍历划分为 [根节点｜左子树｜右子树]</li>
</ol>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="构建中序遍历索引"><a href="#构建中序遍历索引" class="headerlink" title="构建中序遍历索引"></a>构建中序遍历索引</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; idxMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 构建中序遍历的索引，加快查找</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">    idxMap.put(inorder[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归建树"><a href="#递归建树" class="headerlink" title="递归建树"></a>递归建树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// 左边界大于右边界，递归终止</span></span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历的第一个节点为根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preRootIdx</span> <span class="operator">=</span> preStart;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preOrder[preRootIdx];</span><br><span class="line">    <span class="type">int</span> <span class="variable">inRootIdx</span> <span class="operator">=</span> idxMap.get(rootVal);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="comment">// 前序遍历的左子树的左边界为前序遍历的第二个节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preLeftStart</span> <span class="operator">=</span> preStart + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 左子树的节点数为中序遍历的根节点减去中序遍历的左边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> inRootIdx - inStart;</span><br><span class="line">    <span class="comment">// 前序遍历的左子树的右边界为前序遍历的左子树的左边界加上左子树的节点数减一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preLeftEnd</span> <span class="operator">=</span> preLeftStart + leftSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 中序遍历的左子树的左边界为中序遍历的左边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">inLeftStart</span> <span class="operator">=</span> inStart;</span><br><span class="line">    <span class="comment">// 中序遍历的左子树的右边界为中序遍历的根节点减一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">inLeftEnd</span> <span class="operator">=</span> inRootIdx - <span class="number">1</span>;</span><br><span class="line">    root.left = buildTree(preLeftStart, preLeftEnd, inLeftStart, inLeftEnd);</span><br><span class="line">    <span class="comment">// 前序遍历的右子树的左边界为前序遍历的左子树的右边界加一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preRightStart</span> <span class="operator">=</span> preLeftEnd + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 前序遍历的右子树的右边界为前序遍历的右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preRightEnd</span> <span class="operator">=</span> preEnd;</span><br><span class="line">    <span class="comment">// 中序遍历的右子树的左边界为中序遍历的根节点加一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">inRightStart</span> <span class="operator">=</span> inRootIdx + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 中序遍历的右子树的右边界为中序遍历的右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">inRightEnd</span> <span class="operator">=</span> inEnd;</span><br><span class="line">    root.right = buildTree(preRightStart, preRightEnd, inRightStart, inRightEnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>重新排序得到 2 的幂</title>
    <url>/post/ee640515.html</url>
    <content><![CDATA[<h2 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h2><ul>
<li>词频统计</li>
<li>哈希</li>
</ul>
<span id="more"></span>

<h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><ul>
<li>题目要求，按任何顺序（包括原始顺序）将数字重新排序，因此针对每一个数字，只需统计其每一位数字出现的次数，统计结果用字符串存储</li>
<li>题目要求，1 &lt;&#x3D; N &lt;&#x3D; 10^9，因此可以预处理所有2的幂数</li>
</ul>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><ul>
<li>根据词频统计结果进行哈希查找，确认其是否有匹配的2的幂数的词频统计结果</li>
</ul>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="2的幂数预处理"><a href="#2的幂数预处理" class="headerlink" title="2的幂数预处理"></a>2的幂数预处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reorderedPowerOf2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">// 2的幂数预处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">1e9</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    set.add(countDigits(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.contains(countDigits(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="词频统计-1"><a href="#词频统计-1" class="headerlink" title="词频统计"></a>词频统计</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个数字出现次数统计，用字符串形式存储</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">countDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] cnt = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ++cnt[n % <span class="number">10</span>];</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Word Frequency Statistics</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>重新格式化电话号码</title>
    <url>/post/319e7fd2.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>字符串</li>
</ul>
<span id="more"></span>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>正则替换预处理</p>
</li>
<li><p>前面的数字分组处理，特殊处理剩余的数字</p>
</li>
<li><p>当余数为 1 时，需要与前一组数字合并</p>
</li>
<li><p>当余数为 2 时，单组组成一组</p>
</li>
<li><p>当余数为 0 时，需要删除末尾多余的 -</p>
</li>
</ul>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">number = number.replaceAll(<span class="string">&quot;[\\s-]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 剩下的数字个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> n % <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">group</span> <span class="operator">=</span> n / <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 余数为1，需要与前面的一组合并</span></span><br><span class="line"><span class="keyword">if</span> (remain == <span class="number">1</span>) &#123;</span><br><span class="line">    group--;</span><br><span class="line">    remain += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; group; i++) &#123;</span><br><span class="line">    sb.append(number, i * <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">3</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (remain == <span class="number">2</span>) &#123;</span><br><span class="line">    sb.append(number, n - <span class="number">2</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (remain == <span class="number">4</span>) &#123;</span><br><span class="line">    sb.append(number, n - <span class="number">4</span>, n - <span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    sb.append(number, n - <span class="number">2</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 余数为 0，没有剩下的数字，需要去掉最后一个 -</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/reformat-phone-number/">1694. 重新格式化电话号码 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Str</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台阶问题</title>
    <url>/post/77325807.html</url>
    <content><![CDATA[<h1 id="题解方法"><a href="#题解方法" class="headerlink" title="题解方法"></a>题解方法</h1><ul>
<li>动态规划</li>
</ul>
<span id="more"></span>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li>每一级台阶只能从前一级或前两级台阶上跳跃而来</li>
</ul>
<p>$$<br>dp[i] &#x3D; dp[i - 1] + dp[i - 2]<br>$$</p>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-忽略大小写</title>
    <url>/post/d7f3c5c3.html</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul>
<li>实现接口参数忽略大小写</li>
</ul>
<span id="more"></span>

<h1 id="序列化忽略大小写"><a href="#序列化忽略大小写" class="headerlink" title="序列化忽略大小写"></a>序列化忽略大小写</h1><ul>
<li>接口使用 <code>@RequestBody</code> 实现时忽略大小写序列化</li>
<li>配置三选一</li>
</ul>
<h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">jackson</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">mapper</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">accept-case-insensitive-properties</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure>

<h2 id="JacksonConfig"><a href="#JacksonConfig" class="headerlink" title="JacksonConfig"></a>JacksonConfig</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ObjectMapper <span class="title function_">objectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebMvcConfigurationSupport"><a href="#WebMvcConfigurationSupport" class="headerlink" title="WebMvcConfigurationSupport"></a>WebMvcConfigurationSupport</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(mapper);</span><br><span class="line">        converters.add(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="URL-忽略大小写"><a href="#URL-忽略大小写" class="headerlink" title="URL 忽略大小写"></a>URL 忽略大小写</h1><ul>
<li>接口路径忽略大小写</li>
</ul>
<h2 id="WebMvcConfigurationSupport-1"><a href="#WebMvcConfigurationSupport-1" class="headerlink" title="WebMvcConfigurationSupport"></a>WebMvcConfigurationSupport</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="type">AntPathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">        pathMatcher.setCaseSensitive(<span class="literal">false</span>);</span><br><span class="line">        configurer.setPathMatcher(pathMatcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参数忽略大小写"><a href="#参数忽略大小写" class="headerlink" title="参数忽略大小写"></a>参数忽略大小写</h1><h2 id="OncePerRequestFilter"><a href="#OncePerRequestFilter" class="headerlink" title="OncePerRequestFilter"></a>OncePerRequestFilter</h2><ul>
<li>启动类添加 <code>@ServletComponentScan</code></li>
<li>可以通过 <code>urlPatterns</code> 配置拦截路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;caseInsensitiveFilter&quot;, urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveRequestParameterNameFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        filterChain.doFilter(<span class="keyword">new</span> <span class="title class_">CaseInsensitiveParameterNameHttpServletRequest</span>(request), response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveParameterNameHttpServletRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> LinkedCaseInsensitiveMap&lt;String[]&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedCaseInsensitiveMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CaseInsensitiveParameterNameHttpServletRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(request);</span><br><span class="line">            map.putAll(request.getParameterMap());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">            String[] array = <span class="built_in">this</span>.map.get(name);</span><br><span class="line">            <span class="keyword">if</span> (array != <span class="literal">null</span> &amp;&amp; array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.unmodifiableMap(<span class="built_in">this</span>.map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getParameterNames</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.enumeration(<span class="built_in">this</span>.map.keySet());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.map.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/277834439">https://zhuanlan.zhihu.com/p/277834439</a></li>
<li><a href="https://blog.csdn.net/jx520/article/details/112548619">https://blog.csdn.net/jx520/article/details/112548619</a></li>
<li><a href="https://www.cnblogs.com/kjcc/p/14355113.html">https://www.cnblogs.com/kjcc/p/14355113.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring-重复请求参数分析</title>
    <url>/post/beb43021.html</url>
    <content><![CDATA[<h1 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h1><ul>
<li>当出现重复参数名时，所有参数值均会保存在 map 的 相同 key（即参数名）中。</li>
<li>若参数格式为 String，则所有参数值用逗号连接，一次性输出。</li>
<li>若参数格式为 Integer，则只输出第一个参数值。</li>
</ul>
<span id="more"></span>

<h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>参数均用 <code>@RequestParam</code> 注解修饰，则应当是与之相关的参数绑定环节中实现了这样特殊的参数处理。</p>
<h2 id="参数存储"><a href="#参数存储" class="headerlink" title="参数存储"></a>参数存储</h2><ol>
<li><p>使用 RequestParamMethodArgumentResolver 解析 <code>@RequestParam</code> 注释的方法参数,将相同参数名下的所有参数值均存储在一个 String 数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParamMethodArgumentResolver</span> <span class="keyword">extends</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">UriComponentsContributor</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">resolveName</span><span class="params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            String[] paramValues = request.getParameterValues(name);</span><br><span class="line">            <span class="keyword">if</span> (paramValues != <span class="literal">null</span>) &#123;</span><br><span class="line">                arg = (paramValues.length == <span class="number">1</span> ? paramValues[<span class="number">0</span>] : paramValues);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>WebDataBinder</code> 的 <code>convertIfNecessary</code> 方法，实现参数转换处理。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParamMethodArgumentResolver</span> <span class="keyword">extends</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">UriComponentsContributor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, <span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换处理"><a href="#转换处理" class="headerlink" title="转换处理"></a>转换处理</h2><ol>
<li>通过 <code>WebDataBinder</code>、<code>DataBinder</code>、<code>TypeConverterSupport</code> 层层转包至 <code>TypeConverterDelegate</code> 的 <code>convertIfNecessary</code> 方法处理。</li>
<li>通过判断所需格式与当前格式，进行参数转换处理。</li>
</ol>
<h3 id="String-To-String"><a href="#String-To-String" class="headerlink" title="String[] To String"></a>String[] To String</h3><ol>
<li><p>确认所需类型为 String，有合适的 <code>PropertyEditor</code>，但转换值相对于所需类型不可赋值，且当前值的类型不为 String。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> String propertyName, <span class="meta">@Nullable</span> Object oldValue, <span class="meta">@Nullable</span> Object newValue,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">PropertyEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="built_in">this</span>.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);</span><br><span class="line">   <span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> newValue;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> (editor != <span class="literal">null</span> || (requiredType != <span class="literal">null</span> &amp;&amp; !ClassUtils.isAssignableValue(requiredType, convertedValue))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (typeDescriptor != <span class="literal">null</span> &amp;&amp; requiredType != <span class="literal">null</span> &amp;&amp; Collection.class.isAssignableFrom(requiredType) &amp;&amp;</span><br><span class="line">            convertedValue <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         <span class="type">TypeDescriptor</span> <span class="variable">elementTypeDesc</span> <span class="operator">=</span> typeDescriptor.getElementTypeDescriptor();</span><br><span class="line">         <span class="keyword">if</span> (elementTypeDesc != <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; elementType = elementTypeDesc.getType();</span><br><span class="line">            <span class="keyword">if</span> (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) &#123;</span><br><span class="line">               convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (editor == <span class="literal">null</span>) &#123;</span><br><span class="line">         editor = findDefaultEditor(requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
</li>
<li><p>确认当前转换值的类型为 String[]，但所需类型不为数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doConvertValue</span><span class="params">(<span class="meta">@Nullable</span> Object oldValue, <span class="meta">@Nullable</span> Object newValue,</span></span><br><span class="line"><span class="params">                              <span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> PropertyEditor editor)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isArray() &amp;&amp; convertedValue <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">        <span class="comment">// Convert String array to a comma-separated String.</span></span><br><span class="line">        <span class="comment">// Only applies if no PropertyEditor converted the String array before.</span></span><br><span class="line">        <span class="comment">// The CSV String will be passed into a PropertyEditor&#x27;s setAsText method, if any.</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Converting String array to comma-delimited String [&quot;</span> + convertedValue + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认使用逗号作为分隔符，将所有数组的所有元素拼接为一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">StringUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrayToCommaDelimitedString</span><span class="params">(<span class="meta">@Nullable</span> Object[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arrayToDelimitedString(arr, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrayToDelimitedString</span><span class="params">(<span class="meta">@Nullable</span> Object[] arr, String delim)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(arr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectUtils.nullSafeToString(arr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(delim);</span><br><span class="line">        <span class="keyword">for</span> (Object elem : arr) &#123;</span><br><span class="line">            sj.add(String.valueOf(elem));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="String-To-Integer"><a href="#String-To-Integer" class="headerlink" title="String[] To Integer"></a>String[] To Integer</h3><ol>
<li><p>确认当前转换值的类型为 Integer，没有合适的 <code>PropertyEditor</code>，使用 <code>ConversionService</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> String propertyName, <span class="meta">@Nullable</span> Object oldValue, <span class="meta">@Nullable</span> Object newValue,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">PropertyEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="built_in">this</span>.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);</span><br><span class="line"></span><br><span class="line">   <span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="built_in">this</span>.propertyEditorRegistry.getConversionService();</span><br><span class="line">   <span class="keyword">if</span> (editor == <span class="literal">null</span> &amp;&amp; conversionService != <span class="literal">null</span> &amp;&amp; newValue != <span class="literal">null</span> &amp;&amp; typeDescriptor != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">TypeDescriptor</span> <span class="variable">sourceTypeDesc</span> <span class="operator">=</span> TypeDescriptor.forObject(newValue);</span><br><span class="line">      <span class="keyword">if</span> (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (ConversionFailedException ex) &#123;</span><br><span class="line">            <span class="comment">// fallback to default conversion logic below</span></span><br><span class="line">            conversionAttemptEx = ex;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>根据源数据类型与目标数据类型，选择合适的 <code>GenericConverter</code>，通过 <code>ConversionUtils</code> 的 <code>invokeConverter</code> 方法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericConversionService</span> <span class="keyword">implements</span> <span class="title class_">ConfigurableConversionService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>     &#123;</span><br><span class="line">	    ...</span><br><span class="line">        <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getConverter(sourceType, targetType);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ConversionUtils.invokeConverter(converter, source, sourceType, targetType);</span><br><span class="line">            <span class="keyword">return</span> handleResult(sourceType, targetType, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handleConverterNotFound(source, sourceType, targetType);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ConversionUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeConverter</span><span class="params">(GenericConverter converter, <span class="meta">@Nullable</span> Object source,</span></span><br><span class="line"><span class="params">			TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> converter.convert(source, sourceType, targetType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ConversionFailedException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConversionFailedException</span>(sourceType, targetType, source, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择数组的第一个元素，作为参数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ArrayToObjectConverter</span> <span class="keyword">implements</span> <span class="title class_">ConditionalGenericConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (source == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sourceType.isAssignableTo(targetType)) &#123;</span><br><span class="line">			<span class="keyword">return</span> source;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Array.getLength(source) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">firstElement</span> <span class="operator">=</span> Array.get(source, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.conversionService.convert(firstElement, sourceType.elementTypeDescriptor(firstElement), targetType);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/securitit/article/details/110704810">Spring 注解面面通 之 @RequestParam参数绑定源码解析_securitit的博客-CSDN博客_requestparam源码</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Waline</title>
    <url>/post/f44bacfb.html</url>
    <content><![CDATA[<blockquote>
<p>一款基于 Valine 衍生的简洁、安全的评论系统。</p>
</blockquote>
<span id="more"></span>

<h1 id="评论通知"><a href="#评论通知" class="headerlink" title="评论通知"></a>评论通知</h1><ul>
<li><a href="https://waline.js.org/guide/server/notification.html#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5">评论通知 | Waline</a></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>环境变量在Vercel中添加，添加后需要重新部署</li>
<li>配置Gmail时需要设置<code>安全性较低的应用的访问权限</code></li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://waline.js.org/">Waline | Waline</a></p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Waline</category>
      </categories>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/post/a541262a.html</url>
    <content><![CDATA[<h2 id="IoC（控制反转）"><a href="#IoC（控制反转）" class="headerlink" title="IoC（控制反转）"></a>IoC（控制反转）</h2><p>调用类中的方法不是通过new它的对象来实现，而是通过Spring配置来创建对象，然后交给IOC容器来管理我们的对象，使用时去找IOC容器要，根本就不用去管我们需要的这个对象时怎么创建的、什么时候被销毁。</p>
<p>这样一来，类和类之间的关系就变弱了，因为我们没有在一个类中new另一个对象，对象之间的调用、联系都是通过这个IOC容器来获取的，使每一个对象都相对比较独立。</p>
<p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。</p>
<span id="more"></span>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="习惯优于配置"><a href="#习惯优于配置" class="headerlink" title="习惯优于配置"></a>习惯优于配置</h3><p>（Convention Over Configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量、获得简单的好处，而又不失灵活性。</p>
<h3 id="内嵌容器"><a href="#内嵌容器" class="headerlink" title="内嵌容器"></a>内嵌容器</h3><p>内嵌servlet容器，可以直接执行运行项目的main函数。</p>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>Spring Boot Starter 中有两个核心组件∶ 自动配置代码和提供自动配置模块及其它有用的依赖。也就意味着当我们项目中引入某个  Starter，即拥有了此软件的默认使用能力，除非我们需要特定的配置，一般情况下我仅需要少量的配置或者不配置即可使用组件对应的功能。</p>
<p>会根据我们项目中的类路径的jar包，为jar包的类进行自动装配bean。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>Aspect Oriented Programming，面向切面，AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。是提供另一种角度来思考程序的结构，来弥补面向对象编程的不足。</p>
<p>通俗点讲就是提供一个为一个业务实现提供切面注入的机制，通过这种方式，在业务运行中将定义好的切面通过切入点绑定到业务中，以实现将一些特殊的逻辑绑定到此业务中。</p>
<p>举个栗子，项目中有记录操作日志的需求、或者流程变更是记录变更履历，无非就是插表操作，很简单的一个save操作，都是一些记录日志或者其他辅助性的代码。一遍又一遍的重写和调用。不仅浪费了时间，又将项目变得更加的冗余，实在得不偿失。</p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Spring</category>
      </categories>
  </entry>
</search>
